#!/bin/sh
# tlp - power management functions
#
# Copyright (c) 2018 Thomas Koch <linrunner at gmx.net>
# This software is licensed under the GPL v2 or later.
#
# Some concepts and descriptions were adapted from:
# - laptop-mode-tools
# - thinkwiki.org

# ----------------------------------------------------------------------------
# Constants

readonly TLPVER="1.1.901"

readonly CONFFILE=@TLP_CONF@
readonly RUNDIR=@TLP_RUN@

readonly ETHTOOL=ethtool
readonly HDPARM=hdparm
readonly IWC=iwconfig
readonly IW=iw
readonly MODPRO=modprobe
readonly LOGGER=logger
readonly UDEVADM=udevadm
readonly LAPMODE=laptop_mode
readonly NMCLI=nmcli
readonly NMD=NetworkManager
readonly NMTOOL=nm-tool
readonly ENERGYPERF=x86_energy_perf_policy
readonly DBUSSEND=dbus-send
readonly SYSTEMD=systemd
readonly SYSTEMCTL=systemctl
readonly INITCTL=initctl
readonly FLOCK=flock

readonly TPACPIBAT=$LIBDIR/tpacpi-bat # LIBDIR is initialized by main program

readonly TPACPIDIR=/sys/devices/platform/thinkpad_acpi
readonly SMAPIBATDIR=/sys/devices/platform/smapi
readonly ACPIBATDIR=/sys/class/power_supply

readonly RE_TPSMAPI_ONLY='^(Edge( 13.*)?|G41|R[56][012][eip]?|R[45]00|SL[45]10|T23|T[346][0123][p]?|T[45][01]0[s]?|W[57]0[01]|X[346][012][s]?( Tablet)?|X1[02]0e|X[23]0[01][s]?( Tablet)?|Z6[01][mpt])$'
readonly RE_TPACPI_ONLY='^(13.*|25|(Edge )?E[1345][2345678][05][ps]?|Helix.*|L[45][345678]0|P[75][012][s]?|S2|(Edge )?S[245][345][01]*|T[45][345678][01][psu]?|W5[345][01][s]?|X1 Carbon.*|X2[345678]0[s]?( Tablet)?|.*Yoga.*)$'
readonly RE_TPSMAPI_AND_TPACPI='^(X1|X220[s]?( Tablet)?|T[45]20[s]?|W520)$'
readonly RE_TP_NONE='^(L[45]20|SL[345]00|X121e)$'

readonly NETD=/sys/class/net
readonly BLUETOOTHD=/sys/class/bluetooth
readonly PCID=/sys/bus/pci/devices
readonly PCIDRV=/sys/bus/pci/drivers
readonly I915D='/sys/module/i915*/parameters'
readonly RADD=/sys/module/radeon
readonly DMID=/sys/class/dmi/id/
readonly CPU_BOOST_ALL_CTRL=/sys/devices/system/cpu/cpufreq/boost
readonly INTEL_PSTATED=/sys/devices/system/cpu/intel_pstate
readonly CPU_MIN_PERF_PCT=$INTEL_PSTATED/min_perf_pct
readonly CPU_MAX_PERF_PCT=$INTEL_PSTATED/max_perf_pct
readonly CPU_TURBO_PSTATE=$INTEL_PSTATED/no_turbo
readonly AHCID=$PCID'/*/ata*'
readonly BLOCKD='/sys/block/sd*'

readonly USBD=/sys/bus/usb/devices
readonly USB_TIMEOUT=2
readonly USB_TIMEOUT_MS=2000
readonly USB_WWAN_VENDORS="0bdb 05c6 1199"
readonly USB_DONE=usb_done

readonly DOCKGLOB="/sys/devices/platform/dock.?"

readonly MOD_MSR="msr"
readonly MOD_TEMP="coretemp"
readonly MOD_TPSMAPI="tp_smapi"
readonly MOD_TPACPI="acpi_call"

readonly PWRRUNFILE=$RUNDIR/last_pwr
readonly MANUALMODEFILE=$RUNDIR/manual_mode
readonly LOCKFILE=$RUNDIR/lock
readonly LOCKTIMEOUT=2

readonly RDW_NM_LOCK="rdw_nm"
readonly RDW_DOCK_LOCK="rdw_dock"
readonly RDW_LOCKTIME=2

readonly RFSTATEFILE=$RUNDIR/rfkill_saved
readonly BAYSTATEFILE=$RUNDIR/bay_saved

readonly DISK_NOP_WORDS="_ keep"
readonly DEFAULT_DISK_DEVICES="sda"
readonly DEFAULT_DISK_IO_SCHEDULER="cfq"
readonly DEFAULT_PM_DRIVER_BLACKLIST="amdgpu nouveau nvidia radeon"

# ----------------------------------------------------------------------------
# Control
nodebug=0

# ----------------------------------------------------------------------------
# Functions

# --- Sysfiles

catsysfd () { # echo contents of a sysfile; if file is non-existent or
              # read fails, echo default value instead
              # $1: sysfile, $2: default value
    local val="$(cat $1 2> /dev/null)"
    [ -n "$val" ] || val="$2" # sysfile nonexistent or read failed

    printf "%s" $val
    return 0
}

# --- Tests

wordinlist () { # test if word in list
                # $1: word, $2: whitespace-separated list of words
    local word

    if [ -n "${1-}" ]; then
        for word in ${2-}; do
            [ "${word}" != "${1}" ] || return 0 # exact match
        done
    fi

    return 1 # no match
}

echo_debug () { # write debug msg if tag matches -- $1: tag; $2: msg;
    [ "$nodebug" = "1" ] && return 0

    if wordinlist "$1" "$TLP_DEBUG"; then
        $LOGGER -p debug -t "tlp[$$,$PPID]" "$2"
    fi
}

cmd_exists () { # test if command exists -- $1: command
    command -v $1 > /dev/null 2>&1
}

check_sysfs ()  { # check if sysfile exists -- $1: routine; $2: sysfs path
    if wordinlist "sysfs" "$TLP_DEBUG"; then
        if [ ! -e $2 ]; then
            $LOGGER -p debug -t "tlp[$$,$PPID]" "$1: $2 nonexistent"
        fi
    fi
}

test_root () { # test root privilege -- rc: 0=root, 1=not root
    [ "$(id -u)" = "0" ]
}

check_root () { # show error message and exit when root privilege missing
    if ! test_root; then
        echo "Error: missing root privilege." 1>&2
        exit 1
    fi
}

check_tlp_enabled () { # check if TLP is enabled in config file
    # rc: 0=disabled/1=enabled

    if [ ! "$TLP_ENABLE" = "1" ]; then
        echo "Error: TLP power save is disabled. Set TLP_ENABLE=1 in $CONFFILE." 1>&2
        return 1
    else
        return 0
    fi
}

check_laptop_mode_tools () { # check if lmt installed -- rc: 0=not installed, 1=installed
    if cmd_exists $LAPMODE; then
        echo 1>&2
        echo "***Warning: laptop-mode-tools detected, this may cause conflicts with TLP." 1>&2
        echo "            Please uninstall laptop-mode-tools." 1>&2
        echo 1>&2
        echo_debug "pm" "check_laptop_mode_tools: yes"
        return 1
    else
        return 0
    fi
}

check_systemd () { # check if systemd is the active init system (PID 1) and systemctl is installed
                   # rc: 0=yes, 1=no
    [ -d /run/systemd/system ] && cmd_exists $SYSTEMCTL
}

check_upstart () { # check if upstart is active init system (PID 1)
                   # rc: 0=yes, 1=no
    cmd_exists $INITCTL && $INITCTL --version | grep -q upstart
}

check_openrc () { # check if openrc is the active init system (PID 1)
                  # rc: 0=yes, 1=no
    [ -e /run/openrc/softlevel ]
}


# --- PATH
add_sbin2path () { # check if /sbin /usr/sbin in $PATH, otherwise add them
                   # retval: $PATH, $oldpath, $addpath
    local sp

    oldpath="$PATH"
    addpath=""

    for sp in /usr/sbin /sbin; do
        if [ -d $sp ] && [ ! -h $sp ]; then
            # dir exists and is not a symlink
            case ":$PATH:" in
                *":$sp:"*) # $sp already in $PATH
                    ;;

                *) # $sp not in $PATH, add it
                    addpath="$addpath:$sp"
                    ;;
            esac
        fi
    done

    if [ -n "$addpath" ]; then
      export PATH="${PATH}${addpath}"
    fi

    return 0
}

create_rundir () { # make sure $RUNDIR exists
    [ -d $RUNDIR ] || mkdir -p $RUNDIR 2> /dev/null 1>&2
}

# --- Configuration

read_defaults () { # read config file
    if [ -f $CONFFILE ]; then
        . $CONFFILE
        return 0
    else
        return 1
    fi
}

# --- Kernel Modules

load_modules () { # load kernel module(s) -- $*: modules
    local mod

    # verify module loading is allowed (else explicitly disabled)
    # and possible (else implicitly disabled)
    [ "${TLP_LOAD_MODULES:-y}" = "y" ] && [ -e /proc/modules ] || return 0

    # load modules, ignore any errors
    for mod in $*; do
        $MODPRO $mod > /dev/null 2>&1
    done

    return 0
}

# --- DMI

read_dmi () { # read DMI data -- $*: keywords; stdout: dmi strings
    local ds key outr

    outr=""
    for key in $*; do
        ds="$( cat ${DMID}/$key 2> /dev/null | \
                egrep -iv 'not available|to be filled|DMI table is broken' )"
        if [ -n "$outr" ]; then
            [ -n "$ds" ] && outr="$outr $ds"
        else
            outr="$ds"
        fi
    done

    printf '%s' "$outr"
    return 0
}

# --- ThinkPad

check_thinkpad () { # check for ThinkPad hardware and save model string,
                 # load ThinkPad specific kernel modules
                 # rc: 0=ThinkPad, 1=other hardware
                 # retval: $_tpmodel
    local pv

    _tpmodel=""

    if [ -d $TPACPIDIR ]; then
        # kernel module thinkpad_acpi is loaded

        # get DMI product string and sanitize it
        pv="$( read_dmi product_version | tr -C -d '[a-zA-Z0-9 ]' )"

        # check DMI product string for occurrence of "ThinkPad"
        if printf '%s' "$pv" | grep -q "ThinkPad"; then
            # it's a real ThinkPad --> save model substring
            _tpmodel=${pv#ThinkPad }
        fi
    fi

    if [ -n "$_tpmodel" ]; then
        # load tp-smapi when not explicitly unsupported only;
        # prevents kernel error messages
        if ! supports_tpacpi_only && ! supports_no_tp_bat_funcs; then
            load_modules $MOD_TPSMAPI
        fi

        # load acpi-call unconditionally
        load_modules $MOD_TPACPI

        echo_debug "bat" "check_thinkpad: _tpmodel=$_tpmodel"
        return 0
    fi

    # not a ThinkPad
    echo_debug "bat" "check_thinkpad.not_a_thinkpad"
    return 1
}

is_thinkpad () { # check for ThinkPad by saved model string
                 # rc: 0=ThinkPad, 1=other hardware
    [ -n "$_tpmodel" ]
}

# --- Power Source

get_sys_power_supply () { # get current power supply
                          # retval/rc: $_syspwr (0=ac, 1=battery, 2=unknown)

    local psrc

    _syspwr=

    for psrc in /sys/class/power_supply/*; do
        # -f $psrc/type not necessary - cat 2>.. handles this
        case "$(cat $psrc/type 2> /dev/null)" in
            Mains|USB)
                # AC detected, check if online;
                # exclude MacBook Pro 2017 sbs-charger
                if [ "$(cat $psrc/online 2> /dev/null)" = "1" ] \
                    && [ "${psrc##/*/}" != "sbs-charger" ]; then
                    _syspwr=0
                    break
                fi
                # else AC not online => keep $_syspwr as-is
                ;;

            Battery)
                # battery detected, exclude hid peripherals
                if echo "${psrc##/*/}" | grep -vq "hidpp_battery"; then
                    # not hid --> set rc to battery, but don't stop looking for AC
                    _syspwr=1
                fi
                ;;

            *)
                echo_debug "pm" "unknown power supply: ${psrc##/*/}"
                ;;
        esac
    done

    # set pwrsrc to unknown if we haven't seen any AC/battery power source so far
    : ${_syspwr:=2}

    return $_syspwr
}

get_power_state () { # get current power mode -- rc: 0=ac, 1=battery
    # similar to get_sys_power_supply(),
    # but maps unknown power source to TLP_DEFAULT_MODE;
    # returns TLP_DEFAULT_MODE when TLP_PERSISTENT_DEFAULT=1

    get_sys_power_supply
    local rc=$?

    if [ -n "$TLP_DEFAULT_MODE" ] \
        && [ "$TLP_PERSISTENT_DEFAULT" = "1" ]; then
        # persistent mode, use configured default mode
        case "$TLP_DEFAULT_MODE" in
            bat|BAT) rc=1 ;;
            *)       rc=0 ;;
        esac
    else
        # non-persistent mode, use current power source
        if [ $rc -eq 2 ]; then
            # unknown power supply, use configured default mode
            case "$TLP_DEFAULT_MODE" in
                ac|AC)   rc=0 ;;
                bat|BAT) rc=1 ;;
                *)       rc=0 ;; # use AC if no default mode configured
            esac
        fi
    fi

    return $rc
}

compare_and_save_power_state() { # compare $1 to last saved power state,
    # save $1 afterwards when different
    # $1: new state 0=ac, 1=battery
    # rc: 0=different, 1=equal
    local lp

    # read saved state
    lp=$(cat $PWRRUNFILE 2> /dev/null)

    # compare
    if [ -z "$lp" ] || [ "$lp" != "$1" ]; then
        # saved state is nonexistent/empty or is different --> save new state
        create_rundir
        { printf '%s\n' "$1" > $PWRRUNFILE; } 2> /dev/null

        echo_debug "pm" "compare_and_save_power_state($1).different: old=$lp"
        return 0
    else
        echo_debug "pm" "compare_and_save_power_state($1).equal"
        return 1
    fi
}

clear_saved_power_state() { # remove last saved power state

    rm -f $PWRRUNFILE 2> /dev/null

    return 0
}

echo_started_mode () { # print operation mode -- $1: 0=ac mode, 1=battery mode
    if [ "$1" = "0" ]; then
        echo "TLP started in AC mode."
    else
        echo "TLP started in battery mode."
    fi

    return 0
}

set_manual_mode () { # set manual operation mode
    # $1: 0=ac mode, 1=battery mode

    create_rundir
    { printf '%s\n' "$1" > $MANUALMODEFILE; } 2> /dev/null

    echo_debug "pm" "set_manual_mode($1)"
    return 0
}

clear_manual_mode () { # remove manual operation mode

    rm -r $MANUALMODEFILE 2> /dev/null

    echo_debug "pm" "clear_manual_mode"
    return 0
}

get_manual_mode () { # get manual operation mode
    # rc: 0=ok/1=not found
    # retval: $_manual_mode (0=ac, 1=battery)
    local rc=1
    _manual_mode=""

    if [ -f $MANUALMODEFILE ]; then
        # read mode file
        _manual_mode=$(cat $MANUALMODEFILE)
        case $_manual_mode in
            0|1) rc=0 ;;
            "") ;;
            *) _manual_mode="" ;;
        esac
    fi

    echo_debug "pm" "get_manual_mode: manual_mode=$_manual_mode; rc=$rc"
    return $rc
}

# --- Locking and Semaphores

set_run_flag () { # set flag -- $1: flag name
                  # rc: 0=success/1,2=failed
    local rc

    create_rundir
    touch $RUNDIR/$1; rc=$?
    echo_debug "lock" "set_run_flag.touch: $1; rc=$rc"

    return $rc
}

reset_run_flag () { # reset flag -- $1: flag name
    if rm $RUNDIR/$1 2> /dev/null 1>&2 ; then
        echo_debug "lock" "reset_run_flag($1).remove"
    else
        echo_debug "lock" "reset_run_flag($1).not_found"
    fi

    return 0
}

check_run_flag () { # check flag -- $1: flag name
                    # rc: 0=flag set/1=flag not set
    local rc

    [ -f $RUNDIR/$1 ]; rc=$?
    echo_debug "lock" "check_run_flag($1): rc=$rc"

    return $rc
}

lock_tlp () { # get exclusive lock: blocking with timeout
              # $1: lock id (default: tlp)
              # rc: 0=success/1=failed

    create_rundir
    # open file for writing and attach fd 9
    { exec 9> ${LOCKFILE}_${1:-tlp} ; } 2> /dev/null
    # fopen/attach successful --> lock fd 9 exclusive and blocking,
    # wait $LOCKTIME secs to obtain the lock
    if [ $? -eq 0 ] && $FLOCK -x -w $LOCKTIMEOUT 9 ; then
        echo_debug "lock" "lock_tlp.success"
        return 0
    else
        echo_debug "lock" "lock_tlp.failed"
        return 1
    fi
}

lock_tlp_nb () { # get exclusive lock: non-blocking
                 # $1: lock id (default: tlp)
                 # rc: 0=success/1=failed

    create_rundir
    # open file for writing and attach fd 9
    { exec 9> ${LOCKFILE}_${1:-tlp} ; } 2> /dev/null
    # fopen/attach successful --> lock fd 9 exclusive and non-blocking
    if [ $? -eq 0 ] && $FLOCK -x -n 9 ; then
        echo_debug "lock" "lock_tlp_nb.success"
        return 0
    else
        echo_debug "lock" "lock_tlp_nb.failed"
        return 1
    fi
}

unlock_tlp () { # free exclusive lock

    # defer unlock for $X_DEFER_UNLOCK seconds -- debugging only
    [ -n "$X_DEFER_UNLOCK" ] && sleep $X_DEFER_UNLOCK

    # free fd 9
    { exec 9>&- ; } 2> /dev/null
    echo_debug "lock" "unlock_tlp"

    return 0
}

echo_tlp_locked () { # print "locked" message
    echo "TLP is locked by another operation."
    return 0
}

set_timed_lock () { # create timestamp n seconds in the future
    # $1: lock id, $2: lock duration [s]

    local rc
    local lock=${1}_timed_lock_$(date +%s -d "+${2} seconds")

    set_run_flag $lock; rc=$?
    echo_debug "lock" "set_timed_lock($1, $2): $lock; rc=$rc"

    # cleanup obsolete locks
    local time=$(date +%s)
    for lockfile in $RUNDIR/${1}_timed_lock_*; do
        if [ -f $lockfile ]; then
            locktime=${lockfile#${RUNDIR}/${1}_timed_lock_}
            if [ $time -ge $locktime ]; then
                rm -f $lockfile
                echo_debug "lock" "set_timed_lock($1, $2).remove_obsolete: ${lockfile#${RUNDIR}/}"
            fi
        fi
    done

    return $rc
}

check_timed_lock () { # check if active timestamp exists
    # $1: lock id; rc: 0=locked/1=not locked

    local lockfile locktime
    local time=$(date +%s)

    for lockfile in $RUNDIR/${1}_timed_lock_*; do
        if [ -f $lockfile ]; then
            locktime=${lockfile#${RUNDIR}/${1}_timed_lock_}
            if [ $time -lt $(( $locktime - 120 )) ]; then
                # timestamp is more than 120 secs in the future,
                # something weird has happened -> remove it
                rm -f $lockfile
                echo_debug "lock" "check_timed_lock($1).remove_invalid: ${lockfile#${RUNDIR}/}"
            elif [ $time -lt $locktime ]; then
                # timestamp in the future -> we're locked
                echo_debug "lock" "check_timed_lock($1).locked: $time, $locktime"
                return 0
            else
                # obsolete timestamp -> remove it
                rm -f $lockfile
                echo_debug "lock" "check_timed_lock($1).remove_obsolete: ${lockfile#${RUNDIR}/}"
            fi
        fi
    done

    echo_debug "lock" "check_timed_lock($1).not_locked: $time"
    return 1
}

# --- Filesystem

set_laptopmode () { # set kernel laptop mode -- $1: 0=ac mode, 1=battery mode
    check_sysfs "set_laptopmode" "/proc/sys/vm/laptop_mode"

    local isec

    if [ "$1" = "1" ]; then
        isec=${DISK_IDLE_SECS_ON_BAT:-}
    else
        isec=${DISK_IDLE_SECS_ON_AC:-}
    fi
    # replace with empty string if non-numeric chars are contained
    isec=$(printf '%s' "$isec" | egrep '^[0-9]+$')

    if [ -z "$isec" ]; then
        # do nothing if unconfigured or non numeric value
        echo_debug "pm" "set_laptopmode($1).not_configured"
        return 0
    fi

    echo_debug "pm" "set_laptopmode($1): $isec"
    { printf '%s\n' "$isec" > /proc/sys/vm/laptop_mode; } 2> /dev/null

    return 0
}

set_dirty_parms () { # set filesystem buffer params
    # $1: 0=ac mode, 1=battery mode
    # concept from laptop-mode-tools

    local age cage df

    check_sysfs "set_dirty_parms" "/proc/sys/vm"

    if [ "$1" = "1" ]; then
        age=${MAX_LOST_WORK_SECS_ON_BAT:-0}
    else
        age=${MAX_LOST_WORK_SECS_ON_AC:-0}
    fi

    # calc age in centisecs, non numeric values result in "0"
    cage=$(($age * 100))

    if [ "$cage" = "0" ]; then
        # do nothing if unconfigured or invalid age
        echo_debug "pm" "set_dirty_parms($1).not_configured"
        return 0
    fi

    echo_debug "pm" "set_dirty_parms($1): $cage"

    for df in /proc/sys/vm/dirty_writeback_centisecs \
             /proc/sys/vm/dirty_expire_centisecs \
             /proc/sys/fs/xfs/age_buffer_centisecs \
             /proc/sys/fs/xfs/xfssyncd_centisecs; do
        [ -w $df ] && { printf '%s\n' "$cage" > $df; } 2> /dev/null
    done

    [ -w /proc/sys/fs/xfs/xfsbufd_centisecs ] \
        && { printf '%s\n' "3000" > /proc/sys/fs/xfs/xfsbufd_centisecs; } 2> /dev/null

    return 0
}

# --- CPU

check_intel_pstate () { # detect intel_pstate driver -- retval: $intel_pstate
    #  Note: intel_pstate requires Linux 3.9 or higher
    intel_pstate=0

    [ -d $INTEL_PSTATED ] && intel_pstate=1
    return 0
}

set_scaling_governor () { # set scaling governor -- $1: 0=ac mode, 1=battery mode
    local gov cpu

    if [ "$1" = "1" ]; then
        gov=$CPU_SCALING_GOVERNOR_ON_BAT
    else
        gov=$CPU_SCALING_GOVERNOR_ON_AC
    fi

    if [ -n "$gov" ]; then
        echo_debug "pm" "set_scaling_governor($1): $gov"
        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
            [ -f $cpu ] && { printf '%s\n' "$gov" > $cpu; } 2> /dev/null
        done
    fi

    return 0
}

set_scaling_min_max_freq () { # set scaling limits -- $1: 0=ac mode, 1=battery mode
    local minfreq maxfreq cpu

    if [ "$1" = "1" ]; then
        minfreq=$CPU_SCALING_MIN_FREQ_ON_BAT
        maxfreq=$CPU_SCALING_MAX_FREQ_ON_BAT
    else
        minfreq=$CPU_SCALING_MIN_FREQ_ON_AC
        maxfreq=$CPU_SCALING_MAX_FREQ_ON_AC
    fi

    if [ -n "$minfreq" ] && [ "$minfreq" != "0" ]; then
        echo_debug "pm" "set_scaling_min_max_freq($1).min: $minfreq"
        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq; do
            [ -f $cpu ] && { printf '%s\n' "$minfreq" > $cpu; } 2> /dev/null
        done
    fi

    if [ -n "$maxfreq" ] && [ "$maxfreq" != "0" ]; then
        echo_debug "pm" "set_scaling_min_max_freq($1).max: $maxfreq"
        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq; do
            [ -f $cpu ] && { printf '%s\n' "$maxfreq" > $cpu; } 2> /dev/null
        done
    fi

    return 0
}

set_cpu_hwp_pref () { # set HWP energy performance hints -- $1: 0=ac mode, 1=battery mode
    local hwpp cpu
    local avail=0

    check_intel_pstate
    if [ "$intel_pstate" != "1" ]; then
        echo_debug "pm" "set_cpu_perf_pct($1).no_intel_pstate"
        return 0
    fi

    if [ "$1" = "1" ]; then
        hwpp=$CPU_HWP_ON_BAT
    else
        hwpp=$CPU_HWP_ON_AC
    fi

    if [ -n "$hwpp" ]; then
        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/energy_performance_preference; do
            if [ -f $cpu ]; then
                { printf '%s\n' "$hwpp" > $cpu; } 2> /dev/null
                avail=1
            fi
        done
        if [ "$avail" = "1" ]; then
            echo_debug "pm" "set_cpu_hwp_pref($1): $hwpp"
        else
            echo_debug "pm" "set_cpu_hwp_pref($1).no_hwp"
        fi
    else
        echo_debug "pm" "set_cpu_hwp_pref($1).not_configured"
    fi

    return 0
}

set_cpu_perf_pct () { # set Intel P-state performance
                      # $1: 0=ac mode, 1=battery mode
    local min max

    check_intel_pstate
    if [ "$intel_pstate" != "1" ]; then
        echo_debug "pm" "set_cpu_perf_pct($1).no_intel_pstate"
        return 0
    fi

    if [ "$1" = "1" ]; then
        min="${CPU_MIN_PERF_ON_BAT:-}"
        max="${CPU_MAX_PERF_ON_BAT:-}"
    else
        min="${CPU_MIN_PERF_ON_AC:-}"
        max="${CPU_MAX_PERF_ON_AC:-}"
    fi

    if [ ! -f $CPU_MIN_PERF_PCT ]; then
        echo_debug "pm" "set_cpu_perf_pct($1).min.not_supported"
    elif [ -n "$min" ]; then
        { printf '%s\n' "$min" > $CPU_MIN_PERF_PCT; } 2> /dev/null
        echo_debug "pm" "set_cpu_perf_pct($1).min: $min"
    else
        echo_debug "pm" "set_cpu_perf_pct($1).min.not_configured"
    fi

    if [ ! -f $CPU_MAX_PERF_PCT ]; then
        echo_debug "pm" "set_cpu_perf_pct($1).max.not_supported"
    elif [ -n "$max" ]; then
        { printf '%s\n' "$max" > $CPU_MAX_PERF_PCT; } 2> /dev/null
        echo_debug "pm" "set_cpu_perf_pct($1).max: $max"
    else
        echo_debug "pm" "set_cpu_perf_pct($1).max.not_configured"
    fi

    return 0
}

set_cpu_boost_all () { # $1: 0=ac mode, 1=battery mode
    # global cpu boost behavior control based on the current power mode
    #
    # Relevant config option(s): CPU_BOOST_ON_{AC,BAT} with values {'',0,1}
    #
    # Note:
    #  * needs commit #615b7300717b9ad5c23d1f391843484fe30f6c12
    #     (linux-2.6 tree), "Add support for disabling dynamic overclocking",
    #    => requires Linux 3.7 or later

    local val ival

    if [ "$1" = "1" ]; then
        val="${CPU_BOOST_ON_BAT:-}"
    else
        val="${CPU_BOOST_ON_AC:-}"
    fi

    if [ -z "$val" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_cpu_boost_all($1).not_configured"
        return 0
    fi

    check_intel_pstate

    if [ $intel_pstate -eq 1 ]; then
        # use intel_pstate sysfiles
        if [ -f $CPU_TURBO_PSTATE ]; then
            ival=$(($val ^ 1))
            { printf '%s\n' "$ival" > $CPU_TURBO_PSTATE; } 2> /dev/null
            echo_debug "pm" "set_cpu_boost_all($1).intel_pstate: $val"
        else
            echo_debug "pm" "set_cpu_boost_all($1).intel_pstate.cpu_not_supported"
        fi
    elif [ -f $CPU_BOOST_ALL_CTRL ]; then
        # use acpi_cpufreq sysfiles
        # simple test for attribute "w" doesn't work, so actually write
        if { printf '%s\n' "$val" > $CPU_BOOST_ALL_CTRL; } 2> /dev/null; then
            echo_debug "pm" "set_cpu_boost_all($1).acpi_cpufreq: $val"
        else
            echo_debug "pm" "set_cpu_boost_all($1).acpi_cpufreq.cpu_not_supported"
        fi
    else
        echo_debug "pm" "set_cpu_boost_all($1).not_available"
    fi

    return 0
}

set_sched_powersave () { # set multi-core/-thread powersave policy
    # $1: 0=ac mode, 1=battery mode

    local pwr pool sdev
    local avail=0

    if [ "$1" = "1" ]; then
        pwr=${SCHED_POWERSAVE_ON_BAT:-}
    else
        pwr=${SCHED_POWERSAVE_ON_AC:-}
    fi

    if [ -z "$pwr" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_sched_powersave($1).not_configured"
        return 0
    fi

    for pool in mc smp smt; do
        sdev="/sys/devices/system/cpu/sched_${pool}_power_savings"
        if [ -f $sdev ]; then
            echo_debug "pm" "set_sched_powersave($1): ${sdev##/*/} $pwr"
            { printf '%s\n' "$pwr" > "$sdev"; } 2> /dev/null
            avail=1
        fi
    done

    [ "$avail" = "1" ] || echo_debug "pm" "set_sched_powersave($1).not_available"

    return 0
}

set_nmi_watchdog () { # enable/disable nmi watchdog
    local nmiwd=${NMI_WATCHDOG:-}

    if [ -z "$nmiwd" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_nmi_watchdog.not_configured"
        return 0
    fi

    if [ -f /proc/sys/kernel/nmi_watchdog ]; then
        { printf '%s\n' "$nmiwd" > /proc/sys/kernel/nmi_watchdog; } 2> /dev/null
        if [ $? = 0 ]; then
            echo_debug "pm" "set_nmi_watchdog: $nmiwd"
        else
            echo_debug "pm" "set_nmi_watchdog.disabled_by_kernel: $nmiwd"
        fi
    else
        echo_debug "pm" "set_nmi_watchdog.not_available"
    fi

    return 0
}

set_phc_controls () { # set core voltages
    local control
    local ctrl_avail="0"

    phc_controls=${PHC_CONTROLS:-}

    if [ -z "$phc_controls" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_phc_controls.not_configured"
        return 0
    fi

    for control in /sys/devices/system/cpu/cpu*/cpufreq/phc_controls; do
        if [ -f $control ]; then
            echo_debug "pm" "set_phc_controls: $control $phc_controls"
            { printf '%s\n' "$phc_controls" > $control; } 2> /dev/null
            ctrl_avail="1"
        fi
    done

    [ "$ctrl_avail" = "0" ] && echo_debug "pm" "set_phc_controls.not_available"

    return 0
}

set_energy_perf_policy () { # set performance versus energy savings policy
    # $1: 0=ac mode, 1=battery mode

    local perf pnum rc

    if [ "$1" = "1" ]; then
        perf=${ENERGY_PERF_POLICY_ON_BAT:-}
    else
        perf=${ENERGY_PERF_POLICY_ON_AC:-}
    fi
    # translate alphanumeric to numeric values for backward compatibility
    pnum=$(echo $perf | sed -r 's/^performance$/0/;
                                s/^balance-performance$/4/;
                                s/^(default|normal)$/6/;
                                s/^balance-power?$/8/;
                                s/^power(save)?$/15/')

    if [ -z "$pnum" ]; then
        echo_debug "pm" "set_energy_perf_policy($1).not_configured"
    elif ! cmd_exists $ENERGYPERF; then
        # x86_energy_perf_policy not installed
        echo_debug "pm" "set_energy_perf_policy($1).not_available"
    else
        # x86_energy_perf_policy needs kernel module 'msr'
        load_modules $MOD_MSR
        $ENERGYPERF $pnum > /dev/null 2>&1
        rc=$?
        case $rc in
            0) echo_debug "pm" "set_energy_perf_policy($1): $perf($pnum)" ;;
            1) echo_debug "pm" "set_energy_perf_policy($1): $perf($pnum) -- unsupported cpu" ;;
            2) echo_debug "pm" "set_energy_perf_policy($1): $perf($pnum) -- kernel specific x86_energy_perf_policy missing" ;;
            *) echo_debug "pm" "set_energy_perf_policy($1): $perf($pnum) -- unknown rc=$rc " ;;
        esac
        return $rc
    fi

    return 0
}

# --- Storage Devices

check_disk_hdparm_cap () { # check if relevant disk device
    # $1: dev; rc: 0=yes/1=no

    if [ -z "$($HDPARM -I /dev/$1 2>&1 | \
               egrep 'Invalid argument|Invalid exchange|missing sense data|No such device')" ]; then
        return 0
    else
        return 1
    fi
}

echo_disk_model () { # print disk model -- $1: dev
    local model

    model=$($HDPARM -I /dev/$1 2>&1 | grep 'Model Number' | \
      cut -f2 -d: | sed -r 's/^ *//' )
    printf '%s\n' "$model"

    return 0
}

echo_disk_firmware () { # print firmware version --- $1: dev
    local firmware

    firmware=$($HDPARM -I /dev/$1 2>&1 | grep 'Firmware Revision' | \
      cut -f2 -d: | sed -r 's/^ *//' )
    printf '%s\n' "$firmware"

    return 0
}

get_disk_state () { # get disk power state -- $1: dev; retval: $disk_state
    disk_state=$($HDPARM -C /dev/$1 2>&1 | awk -F ':' '/drive state is/ { gsub(/ /,"",$2); print $2; }')
    [ -z "$disk_state" ] && disk_state="(not available)"

    return 0
}

spindown_disk () { # stop spindle motor -- $1: dev
    $HDPARM -y /dev/$1 > /dev/null 2>&1

    return 0
}

get_disk_apm_level () { # get disk apm level -- $1: dev; rc: apm
    local apm

    apm=$($HDPARM -I /dev/$1 2>&1 | grep 'Advanced power management level' | \
          cut -f2 -d: | egrep "^ *[0-9]+ *$")
    if [ -n "$apm" ]; then
        return $apm
    else
        return 0
    fi

}

get_disk_trim_capability () { # check for trim capability
    # $1: dev; rc: 0=no, 1=yes, 254=no ssd device

    local trim

    if [ -n "$($HDPARM -I /dev/$1 2>&1 | grep 'Solid State Device')" ]; then
        if [ -n "$($HDPARM -I /dev/$1 2>&1 | grep 'TRIM supported')" ]; then
            trim=1
        else
            trim=0
        fi
    else
        trim=255
    fi

    return $trim
}

get_disk_dev () { # translate disk id to device (sdX)
    # $1: id or dev; retval: $disk_dev, $disk_id

    if [ -h /dev/disk/by-id/$1 ]; then
        # $1 is disk id
        disk_id=$1
        disk_dev=$(printf '%s' "$disk_id" | sed -r 's/-part[1-9][0-9]*$//')
        disk_dev=$(readlink /dev/disk/by-id/$disk_dev)
        disk_dev=${disk_dev##*/}
    else
        # $1 is disk dev
        disk_dev=$1
        disk_id=""
    fi
}

set_disk_apm_level () { # set disk apm level
    # $1: 0=ac mode, 1=battery mode

    local pwrmode="$1"
    local dev log_message

    # when undefined use default
    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}

    # set @argv := apmlist (blanks removed - relying on a sane $IFS)
    if [ "$pwrmode" = "1" ]; then
        set -- $DISK_APM_LEVEL_ON_BAT
    else
        set -- $DISK_APM_LEVEL_ON_AC
    fi

    # exit if empty apmlist
    [ $# -gt 0 ] || return 0

    # pairwise iteration DISK_DEVICES[1,n], apmlist[1,m]; m > 0
    #  for j in [1,n]: disk_dev[j], apmlist[min(j,m)]
    #
    for dev in $DISK_DEVICES; do
        : ${1:?BUG: broken DISK_APM_LEVEL list handling}

        get_disk_dev $dev
        log_message="set_disk_apm_level($pwrmode): $disk_dev [$disk_id] $1"

        if [ ! -b /dev/$disk_dev ]; then
            echo_debug "disk" "${log_message} -- missing"
        elif ! check_disk_hdparm_cap $disk_dev; then
            echo_debug "disk" "${log_message} -- not supported"
        elif wordinlist "$1" "$DISK_NOP_WORDS"; then
            echo_debug "disk" "${log_message} -- keep as is"
        else
            echo_debug "disk" "${log_message}"
            $HDPARM -B $1 /dev/$disk_dev > /dev/null 2>&1
        fi

        # last entry in apmlist applies to all remaining disks
        [ $# -lt 2 ] || shift
    done

    return 0
}

set_disk_spindown_timeout () { # set disk spindown timeout
    # $1: 0=ac mode, 1=battery mode

    local pwrmode="$1"
    local dev log_message

    # when undefined use default
    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}

    # set @argv := timeoutlist
    if [ "$pwrmode" = "1" ]; then
        set -- $DISK_SPINDOWN_TIMEOUT_ON_BAT
    else
        set -- $DISK_SPINDOWN_TIMEOUT_ON_AC
    fi

    # exit if empty timeoutlist
    [ $# -gt 0 ] || return 0

    # pairwise iteration DISK_DEVICES[1,n], timeoutlist[1,m]; m > 0
    #  for j in [1,n]: disk_dev[j], timeoutlist[min(j,m)]
    #
    for dev in $DISK_DEVICES; do
        : ${1:?BUG: broken DISK_SPINDOWN_TIMEOUT list handling}

        get_disk_dev $dev
        log_message="set_disk_spindown_timeout($pwrmode): $disk_dev [$disk_id] $1"

        if [ ! -b /dev/$disk_dev ]; then
            echo_debug "disk" "${log_message} -- missing"
        elif ! check_disk_hdparm_cap $disk_dev; then
            echo_debug "disk" "${log_message} -- not supported"
        elif wordinlist "$1" "$DISK_NOP_WORDS"; then
            echo_debug "disk" "${log_message} -- keep as is"
        else
            echo_debug "disk" "${log_message}"
            $HDPARM -S $1 /dev/$disk_dev > /dev/null 2>&1
        fi

        # last entry in timeoutlist applies to all remaining disks
        [ $# -lt 2 ] || shift
    done

    return 0
}

set_disk_io_sched () { # set disk io scheduler
    local dev sched schedctrl log_message

    # when undefined use default
    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}

    # set @argv := schedlist
    set -- $DISK_IOSCHED

    # exit if empty timeoutlist
    [ $# -gt 0 ] || return 0

    # pairwise iteration DISK_DEVICES[1,n], schedlist[1,m]; m > 0
    #  for j in [1,min(n,m)]   : disk_dev[j], schedlistj]
    #  for j in [min(n,m)+1,n] : disk_dev[j], %DEFAULT_DISK_IO_SCHEDULER
    for dev in $DISK_DEVICES; do
        get_disk_dev $dev

        # get sched from argv, use default scheduler when list is too short
        sched=${1:-${DEFAULT_DISK_IO_SCHEDULER}}
        schedctrl="/sys/block/$disk_dev/queue/scheduler"
        log_message="set_disk_io_sched: $disk_dev [$disk_id] $sched"

        if [ ! -b /dev/$disk_dev ]; then
            echo_debug "disk" "${log_message} -- missing"
        elif [ ! -f $schedctrl ]; then
            echo_debug "disk" "${log_message} -- not supported"
        elif wordinlist "$sched" "$DISK_NOP_WORDS"; then
            echo_debug "disk" "${log_message} -- keep as is"
        else
            echo_debug "disk" "${log_message}"
            { printf '%s' "$sched" > $schedctrl; } 2> /dev/null
        fi

        # using %DEFAULT_DISK_IO_SCHEDULER when argv is empty
        [ $# -eq 0 ] || shift
    done

    return 0
}

# --- Device Power Management

set_sata_link_power () { # set ahci link power management
    # $1: 0=ac mode, 1=battery mode

    local pm="$1"
    local host host_bl hostid linkpol pwr rc
    local pwrlist=""
    local pwr_bl=""
    local ctrl_avail="0"

    if [ "$pm" = "1" ]; then
        pwrlist=${SATA_LINKPWR_ON_BAT:-}
    else
        pwrlist=${SATA_LINKPWR_ON_AC:-}
    fi

    if [ -z "$pwrlist" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_sata_link_power($pm).not_configured"
        return 0
    fi

    # ALPM blacklist
    host_bl=${SATA_LINKPWR_BLACKLIST:-}

    # copy configured values to args
    set -- $pwrlist
    # iterate SATA hosts
    for host in /sys/class/scsi_host/host* ; do
        linkpol=$host/link_power_management_policy
        if [ -f $linkpol ]; then
            hostid=${host##*/}
            if wordinlist "$hostid" "$host_bl"; then
                # host blacklisted --> skip
                echo_debug "pm" "set_sata_link_power($pm).black: $host"
                ctrl_avail="1"
            else
                # host not blacklisted --> iterate all configured values
                for pwr in "$@"; do
                    { printf '%s\n' "$pwr" > $linkpol; } 2> /dev/null; rc=$?
                    echo_debug "pm" "set_sata_link_power($pm).$pwr: $host; rc=$rc"
                    if [ $rc -eq 0 ]; then
                        # write successful --> goto next host
                        ctrl_avail="1"
                        break
                    else
                        # write failed --> don't use this value for remaining hosts
                        # and try next value
                        shift
                    fi
                done
            fi
        fi
    done

    [ "$ctrl_avail" = "0" ] && echo_debug "pm" "set_sata_link_power($pm).not_available"
    return 0
}

set_pcie_aspm () { # set pcie active state power management
    # $1: 0=ac mode, 1=battery mode

    local pwr

    if [ "$1" = "1" ]; then
        pwr=${PCIE_ASPM_ON_BAT:-}
    else
        pwr=${PCIE_ASPM_ON_AC:-}
    fi

    if [ -z "$pwr" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_pcie_aspm($1).not_configured"
        return 0
    fi

    if [ -f /sys/module/pcie_aspm/parameters/policy ]; then
        { printf '%s\n' "$pwr" > /sys/module/pcie_aspm/parameters/policy; } 2> /dev/null
        if [ $? = 0 ]; then
            echo_debug "pm" "set_pcie_aspm($1): $pwr"
        else
            echo_debug "pm" "set_pcie_aspm($1).disabled_by_kernel"
        fi
    else
        echo_debug "pm" "set_pcie_aspm($1).not_available"
    fi

    return 0
}

set_radeon_profile () { # set radeon power profile
    # $1: 0=ac mode, 1=battery mode

    local card level pwr rc1 rc2
    local sdone=0 # 1=radeon present

    if [ ! -d $RADD ]; then
        # No card present --> exit
        echo_debug "pm" "set_radeon_profile($1).no_card"
        return 0
    fi

    for card in /sys/class/drm/card[0-9]/device ; do
        if [ -f $card/power_dpm_state ] && [ -f $card/power_dpm_force_performance_level ]; then
            # Use new radeon dynamic power management method (dpm)
            if [ "$1" = "1" ]; then
                pwr=${RADEON_DPM_STATE_ON_BAT:-}
                level=${RADEON_DPM_PERF_LEVEL_ON_BAT:-auto}
            else
                pwr=${RADEON_DPM_STATE_ON_AC:-}
                level=${RADEON_DPM_PERF_LEVEL_ON_AC:-auto}
            fi

            if [ -z "$pwr" ]; then
                # do nothing if unconfigured
                echo_debug "pm" "set_radeon_profile($1).not_configured: $card"
                return 0
            fi

            if [ -n "$pwr" ]; then
                { printf '%s\n' "$pwr" > $card/power_dpm_state; } 2> /dev/null; rc1=$?
                { printf '%s\n' "$level" > $card/power_dpm_force_performance_level; } 2> /dev/null; rc2=$?
                echo_debug "pm" "set_radeon_profile($1): $card state=$pwr [rc=$rc1] perf=$level [rc=$rc2]"
            fi

            sdone=1

        elif [ -f $card/power_method ] && [ -f $card/power_profile ]; then
            # Use old radeon power profile method
            if [ "$1" = "1" ]; then
                pwr=${RADEON_POWER_PROFILE_ON_BAT:-}
            else
                pwr=${RADEON_POWER_PROFILE_ON_AC:-}
            fi

            if [ -z "$pwr" ]; then
                # do nothing if unconfigured
                echo_debug "pm" "set_radeon_profile($1).not_configured: $card"
                return 0
            fi

            if [ -n "$pwr" ]; then
                echo_debug "pm" "set_radeon_profile($1): $card profile=$pwr"
                { printf '%s\n' "profile" > $card/power_method; } 2> /dev/null
                { printf '%s\n' "$pwr" > $card/power_profile; } 2> /dev/null
            fi

            sdone=1
        fi
    done

    if [ $sdone -eq 0 ]; then
        echo_debug "pm" "set_radeon_profile($1).not_available"
    fi

    return 0
}

set_sound_power_mode () { # set sound chip power modes
    # $1: 0=ac mode, 1=battery mode

    local pwr cpwr

    # new config param
    if [ "$1" = "1" ]; then
        pwr=${SOUND_POWER_SAVE_ON_BAT:-}
    else
        pwr=${SOUND_POWER_SAVE_ON_AC:-}
    fi

    # when unconfigured consider legacy config param
    [ -z "$pwr" ] && pwr=${SOUND_POWER_SAVE:-}

    if [ -z "$pwr" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_sound_power_mode($1).not_configured"
        return 0
    fi

    cpwr=${SOUND_POWER_SAVE_CONTROLLER:-Y}

    check_sysfs "set_sound_power_mode" "/sys/module"

    if [ -d /sys/module/snd_hda_intel ]; then
        echo_debug "pm" "set_sound_power_mode($1).hda: $pwr controller=$cpwr"
        { printf '%s\n' "$pwr" > /sys/module/snd_hda_intel/parameters/power_save; } 2> /dev/null

        if [ "$pwr" = "0" ]; then
            { printf '%s\n' "N" >  /sys/module/snd_hda_intel/parameters/power_save_controller; } 2> /dev/null
        else
            { printf '%s\n' "$cpwr" > /sys/module/snd_hda_intel/parameters/power_save_controller; } 2> /dev/null
        fi
    fi

    if [ -d /sys/module/snd_ac97_codec ]; then
        echo_debug "pm" "set_sound_power_mode($1).ac97: $pwr"
        { printf '%s\n' "$pwr"  > /sys/module/snd_ac97_codec/parameters/power_save; } 2> /dev/null
    fi

    return 0
}

set_runtime_pm () { # set runtime power management
    # $1: 0=ac mode, 1=battery mode

    local address class ccontrol control device driver drv_bl pci_bl type vendor

    if [ "$1" = "1" ]; then
        ccontrol=${RUNTIME_PM_ON_BAT:-}
    else
        ccontrol=${RUNTIME_PM_ON_AC:-}
    fi

    if [ -z "$ccontrol" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_runtime_pm($1).not_configured"
        return 0
    fi

    # driver specific blacklist:
    # - undefined = use internal default from $DEFAULT_PM_DRIVER_BLACKLIST
    # - empty     = disable feature
    drv_bl="${RUNTIME_PM_DRIVER_BLACKLIST-${DEFAULT_PM_DRIVER_BLACKLIST}}"

    # pci id blacklist
    pci_bl=${RUNTIME_PM_BLACKLIST:-}

    # add devices assigned to blacklisted drivers to the pci id blacklist
    for driver in $drv_bl; do # iterate list
        if [ -n "$driver" ] && [ -d $PCIDRV/$driver ]; then
            # driver is active --> iterate over assigned devices
            for device in $PCIDRV/$driver/0000:*; do
                # get short device address
                address=${device##/*/0000:}

                # add to list when not already contained
                if ! wordinlist "$address" "$pci_bl"; then
                    pci_bl="$pci_bl $address"
                fi
            done # for device
        fi # if driver
    done # for driver

    # iterate pci(e) devices
    for type in $PCID; do
        for device in $type/*; do
            if [ -f $device/power/control ]; then
                # get short device address, class
                address=${device##/*/0000:}
                class=$(cat $device/class 2> /dev/null)

                if wordinlist "$address" "$pci_bl"; then
                    # device is in address blacklist
                    control="black_address"

                else
                    control=$ccontrol

                    # check for Nvidia gpu's
                    if wordinlist "nouveau" "$drv_bl" || wordinlist "nvidia" "$drv_bl"; then
                        # driver nouveau or nvidia is in blacklist
                        # --> blacklist depending on vendor and class
                        vendor=$(cat $device/vendor 2> /dev/null)

                        if [ "$vendor" = "0x10de" ]; then
                            # vendor nvidia
                            # --> check for display or 3d controller class
                            case $class in
                                "0x030000") control="black_nvgpu" ;;
                                "0x030200") control="black_nvgpu" ;;
                            esac
                        fi
                    fi # if nouveau | nvidia blacklisted

                    case $control in
                        auto|on) { printf '%s\n' $control > $device/power/control; } 2> /dev/null ;;
                        *) ;; # do nothing
                    esac
                fi #

                echo_debug "pm" "set_runtime_pm($1).$control: $device [$class]"
            fi # if class && control
        done # for device
    done # for type

    return 0
}

set_ahci_runtime_pm () { # set ahci runtime power management
    # $1: 0=ac mode, 1=battery mode

    local control device timeout rc

    if [ "$1" = "1" ]; then
        control=${AHCI_RUNTIME_PM_ON_BAT:-}
    else
        control=${AHCI_RUNTIME_PM_ON_AC:-}
    fi

    # calc timeout in millisecs, default to 15000
    timeout=$((${AHCI_RUNTIME_PM_TIMEOUT:-15} * 1000))
    [ "$timeout" != "0" ] || timeout=15000

    # check values
    case "$control" in
        on|auto)       ;;
        *) control="" ;; # invalid input --> unconfigured
    esac

    if [ -z "$control" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_ahci_runtime_pm($1).not_configured"
        return 0
    fi

    # iterate ahci devices
    for device in $AHCID; do
        if [ -f ${device}/power/control ]; then
            { printf '%s\n' $control $control > ${device}/power/control; } 2> /dev/null
            echo_debug "pm" "set_ahci_runtime_pm($1).$control: host=$device"
        fi
    done

    # iterate block devices
    for device in $BLOCKD; do
        if [ -f ${device}/device/power/control ]; then
            # write timeout first because writing "auto" with the default
            # timeout -1 still active will lockup the machine!
            rc=0

            if { printf '%s\n' "$timeout" > ${device}/device/power/autosuspend_delay_ms; } 2> /dev/null; then
                # writing timeout was successful --> proceed with activation;
                # rc=2 when unsuccessful
                { printf '%s\n' $control > ${device}/device/power/control; } 2> /dev/null || rc=2
            else
                # writing timeout was successful
                rc=1
            fi

            echo_debug "pm" "set_ahci_runtime_pm($1).$control: disk=$device timeout=$timeout; rc=$rc"
        fi
    done

    return 0
}

# --- Wifi Power Management

get_wifi_ifaces () { # get all wifi devices -- retval: $wifaces
    local wi wiu
    wifaces=""

    for wiu in $NETD/*/uevent; do
        if grep -q -s "DEVTYPE=wlan" $wiu ; then
            wi=${wiu%/uevent}; wi=${wi##*/}
            wifaces="$wifaces $wi"
        fi
    done

    wifaces="${wifaces# }"
    return 0
}

get_wifi_driver () { # get driver associated with interface
                     # $1: iface; retval: $wifidrv
    local drvl

    wifidrv=""
    if [ -d $NETD/$1 ]; then
        drvl=$(readlink $NETD/$1/device/driver)
        [ -n "$drvl" ] && wifidrv=${drvl##*/}
    fi

    return 0
}

set_wifi_power_mode () { # set wifi power save mode -- $1: 0=ac mode, 1=battery mode
    local pwr iface
    local rc=0
    local cmdx=0

    if [ "$1" = "1" ]; then
        pwr=${WIFI_PWR_ON_BAT:-}
    else
        pwr=${WIFI_PWR_ON_AC:-}
    fi

    # check values, translate obsolete syntax
    case "$pwr" in
        off|on)      ;;
        0|1|N)       pwr="off" ;;
        2|3|4|5|6|Y) pwr="on"  ;;
        *)           pwr=""    ;; # invalid input --> unconfigured
    esac

    if [ -z "$pwr" ]; then
        # do nothing if unconfigured
        echo_debug "pm" "set_wifi_power_mode($1).not_configured"
        return 0
    fi

    get_wifi_ifaces
    if [ -z "$wifaces" ]; then
        echo_debug "pm" "set_wifi_power_mode($1).no_ifaces"
        return 0
    fi

    for iface in $wifaces; do
        if [ -n "$iface" ]; then
            if  [ "$X_DONT_USE_IW" != "1" ] && cmd_exists $IW; then
                # try with iw first
                $IW dev $iface set power_save $pwr > /dev/null 2>&1
                rc=$?
                echo_debug "pm" "set_wifi_power_mode($1, $iface).iw: $pwr; rc=$rc"
                cmdx=1 # set flag: iw found and called
            fi
            if cmd_exists $IWC; then
                if [ $rc -ne 0 ] || [ $cmdx -eq 0 ]; then
                    # iw did not succeed or iw not installed -> try with iwconfig
                    $IWC $iface power $pwr > /dev/null 2>&1
                    rc=$?
                    echo_debug "pm" "set_wifi_power_mode($1, $iface).iwconfig: $pwr; rc=$rc"
                    cmdx=1 # set flag: iwconfig found and called
                fi
            fi
            if [ $cmdx -eq 0 ]; then
                # flag not set: neither iw nor iwconfig installed --> no way
                echo_debug "pm" "set_wifi_power_mode($1, $iface).no_tool"
            fi
        fi
    done

    return 0
}

wireless_in_use () { # check if wifi or wwan device is in use -- $1: iface
    if [ -f $NETD/$1/carrier ]; then
        if [ "$(cat $NETD/$1/carrier 2>/dev/null)" = "1" ]; then
            return 0
        fi
    fi
    return 1
}

any_wifi_in_use () { # check if any wifi device is in use
    local iface

    get_wifi_ifaces
    for iface in $wifaces; do
        wireless_in_use $iface && return 0
    done

    return 1
}

# --- WWAN Device Checks

get_wwan_ifaces () { # get all wwan devices -- retval: $wanifaces
    local wi wiu
    wanifaces=""

    for wiu in $NETD/*/uevent; do
        if grep -q -s "DEVTYPE=wwan" $wiu ; then
            wi=${wiu%/uevent}; wi=${wi##*/}
            wanifaces="$wanifaces $wi"
        fi
    done

    wanifaces="${wanifaces# }"
    return 0
}

any_wwan_in_use () { # check if any wwan device is in use
    local iface

    get_wwan_ifaces
    for iface in $wanifaces; do
        wireless_in_use $iface && return 0
    done

    return 1
}

get_wwan_driver () { # get driver associated with interface
                     # $1: iface; retval: $wwandrv
    local drvl

    wwandrv=""
    if [ -d $NETD/$1 ]; then
        drvl=$(readlink $NETD/$1/device/driver)
        [ -n "$drvl" ] && wwandrv=${drvl##*/}
    fi

    return 0
}

# --- Bluetooth Device Checks

get_bluetooth_ifaces () { # get all bluetooth interfaces -- retval: $bifaces
    # enumerate symlinks only
    bifaces="$(for i in $BLUETOOTHD/*; do [ -h $i ] && echo ${i##/*/}; done | grep -v ':')"
    return 0
}

get_bluetooth_driver () { # get driver associated with interface -- $1: iface; retval: $bluetoothdrv
    local drvl

    bluetoothdrv=""
    if [ -d $BLUETOOTHD/$1 ]; then
        drvl=$(readlink $BLUETOOTHD/$1/device/driver)
        [ -n "$drvl" ] && bluetoothdrv=${drvl##*/}
    fi

    return 0
}

bluetooth_in_use () { # check if bluetooth interface is in use -- $1: iface
    local uev

    # when devices are connected to an interface its sysdir is populated with
    # subdevices like <iface>:<number> where the uevent file contains a line
    # "DEVTYPE=link"
    for uev in $BLUETOOTHD/$1/$1:*/uevent; do
        grep -qs "DEVTYPE=link" $uev && return 0
    done

    return 1
}

any_bluetooth_in_use () { # check if any bluetooth interface is in use
    local i

    get_bluetooth_ifaces
    for i in $bifaces; do
        bluetooth_in_use "$i" && return 0
    done

    return 1
}

# --- LAN

get_eth_ifaces () { # get all eth devices -- retval: $ethifaces
    local ei eic
    ethifaces=""

    for eic in $NETD/*/device/class; do
        if [ "$(cat $eic 2> /dev/null)" = "0x020000" ] \
            && [ ! -d "${eic%/class}/ieee80211" ]; then

            ei=${eic%/device/class}; ei=${ei##*/}
            ethifaces="$ethifaces $ei"
        fi
    done

    ethifaces="${ethifaces# }"
    return 0
}

disable_wake_on_lan () {  # disable WOL
    local ei

    WOL_DISABLE=${WOL_DISABLE:-N}

    if [ "$WOL_DISABLE" = "Y" ]; then
        get_eth_ifaces

        for ei in $ethifaces; do
            echo_debug "pm" "disable_wake_on_lan: $ei"
            $ETHTOOL -s $ei wol d > /dev/null 2>&1
        done
    fi

    return 0
}

# --- USB Autosuspend

set_usb_suspend () { # activate usb autosuspend for all devices except input and blacklisted
    # $1: 0=silent/1=report result; $2: on/auto

    local busdev control dclass devices exc subdev usbd usbdev usbid vendor
    local ctrlf="control"
    local autof="autosuspend_delay_ms"
    local drvlist=""

    check_sysfs "set_usb_suspend" "$USBD"

    if [ "$USB_AUTOSUSPEND" = "1" ]; then
        # autosuspend is configured

        # iterate devices
        devices=$(ls $USBD 2> /dev/null | grep -v ':')

        for usbd in $devices; do
            # concat full device path
            usbdev=$USBD/$usbd

            if [ -f $usbdev/power/autosuspend ] || [ -f $usbdev/power/autosuspend_delay_ms ]; then
                vendor="$(cat $usbdev/idVendor 2> /dev/null)"
                usbid="$vendor:$(cat $usbdev/idProduct 2> /dev/null)"
                busdev="Bus $(cat $usbdev/busnum 2> /dev/null) Dev $(cat $usbdev/devnum 2> /dev/null)"
                dclass="$(cat $usbdev/bDeviceClass 2> /dev/null)"
                control="${2:-auto}"
                exc=""
                chg=0

                # trace only: get drivers for the device and all subdevices
                if [ "$X_USB_DRIVER_TRACE" = "1" ]; then
                    drvlist=$(for dl in $usbdev/*:*/driver; do readlink $dl | \
                        sed -r 's/.+\///'; done | sort -u | tr '\n' ' ')
                    drvlist="(${drvlist% })"
               fi

                if [ "$control" != "on" ]; then
                    if wordinlist "$usbid" "$USB_WHITELIST"; then
                        # device is in whitelist -- whitelist always wins
                        control="auto"
                        exc="_dev_white"
                    elif wordinlist "$usbid" "$USB_BLACKLIST"; then
                        # device is in blacklist
                        control="on"
                        exc="_dev_black"
                    else
                        # check for hid subdevices
                        for subdev in $usbdev/*:*; do
                            if [ "$(cat $subdev/bInterfaceClass 2> /dev/null)" = "03" ]; then
                                control="on"
                                exc="_hid_black"
                                break
                            fi
                        done

                        if [ -z "$exc" ]; then
                            # check for bluetooth devices
                            USB_BLACKLIST_BTUSB=${USB_BLACKLIST_BTUSB:-0} # default is include

                            if [ "$USB_BLACKLIST_BTUSB" = "1" ] \
                                && [ "$dclass" = "e0" ] \
                                && [ "$(cat $usbdev/bDeviceSubClass 2> /dev/null)" = "01" ] \
                                && [ "$(cat $usbdev/bDeviceProtocol 2> /dev/null)" = "01" ]; then
                                control="on"
                                exc="_btusb_black"
                            fi
                        fi # bluetooth

                        if [ -z "$exc" ]; then
                            # check for phone devices
                            USB_BLACKLIST_PHONE=${USB_BLACKLIST_PHONE:-0} # default is include

                            if [ "$USB_BLACKLIST_PHONE" = "1" ]; then
                                if [ "$vendor" = "0fca" ]; then
                                    # RIM
                                    if [ "$dclass" = "ef" ]; then
                                        # RIM / BlackBerry
                                        control="on"
                                        exc="_phone_black"
                                    elif [ "$dclass" = "00" ]; then
                                       for subdev in $usbdev/*:*; do
                                            if [ -d $subdev ]; then
                                                if [ "$(cat $subdev/interface 2> /dev/null)" = "BlackBerry" ]; then
                                                    # Blackberry
                                                    control="on"
                                                    exc="_phone_black"
                                                    break
                                                fi
                                            fi
                                        done
                                    fi

                                elif [ "$vendor" = "045e" ] && [ "$dclass" = "ef" ]; then
                                    # Windows Phone
                                    control="on"
                                    exc="_phone_black"

                                elif [ "$vendor" = "05ac" ] && [ "$(cat $usbdev/product 2> /dev/null)" = "iPhone" ]; then
                                    # iPhone
                                    control="on"
                                    exc="_phone_black"

                                elif [ "$dclass" = "00" ]; then
                                    # class defined at interface level, iterate subdevices
                                    for subdev in $usbdev/*:*; do
                                        if [ -d $subdev ]; then
                                            if [ "$(cat $subdev/interface 2> /dev/null)" = "MTP" ]; then
                                                # MTP: mostly Android
                                                control="on"
                                                exc="_phone_black"
                                                break
                                            elif [ "$(cat $subdev/bInterfaceClass 2> /dev/null)" = "ff" ] \
                                                && [ "$(cat $subdev/bInterfaceSubClass 2> /dev/null)" = "42" ] \
                                                && [ "$(cat $subdev/bInterfaceProtocol 2> /dev/null)" = "01" ]; then
                                                # ADB: Android
                                                control="on"
                                                exc="_phone_black"
                                                break
                                            elif [ "$(cat $subdev/bInterfaceClass 2> /dev/null)" = "06" ] \
                                                && [ "$(cat $subdev/bInterfaceSubClass 2> /dev/null)" = "01" ] \
                                                && [ "$(cat $subdev/bInterfaceProtocol 2> /dev/null)" = "01" ]; then
                                                # PTP: iPhone, Lumia et al.
                                                # caveat: may also be a camera
                                                control="on"
                                                exc="_phone_black"
                                                break
                                            fi
                                        fi
                                    done

                                fi # dclass 00
                            fi # blacklist phone
                        fi # phone

                        if [ -z "$exc" ]; then
                            # check for printers
                            USB_BLACKLIST_PRINTER=${USB_BLACKLIST_PRINTER:-1} # default is exclude

                            if [ "$USB_BLACKLIST_PRINTER" = "1" ]; then
                                if [ "$dclass" = "00" ]; then
                                    # check for printer subdevices
                                    for subdev in $usbdev/*:*; do
                                        if [ "$(cat $subdev/bInterfaceClass 2> /dev/null)" = "07" ]; then
                                            control="on"
                                            exc="_printer_black"
                                            break
                                        fi
                                    done
                                fi
                            fi
                        fi # printer

                        if [ -z "$exc" ]; then
                            # check for wwan devices
                            USB_BLACKLIST_WWAN=${USB_BLACKLIST_WWAN:-1} # default is exclude

                            if [ "$USB_BLACKLIST_WWAN" = "1" ]; then
                                if [ "$dclass" != "00" ]; then
                                    # check for cdc subdevices
                                    for subdev in $usbdev/*:*; do
                                        if [ "$(cat $subdev/bInterfaceClass 2> /dev/null)" = "0a" ]; then
                                            control="on"
                                            exc="_wwan_black"
                                            break
                                        fi
                                    done

                                    if [ -z "$exc" ]; then
                                        # check for vendors
                                        if wordinlist "$vendor" "$USB_WWAN_VENDORS"; then
                                            control="on"
                                            exc="_wwan_black"
                                        fi
                                    fi
                                fi
                            fi # blacklist wwan
                        fi # wwan
                    fi # !device blacklist
                fi # control=on

                if [ -f $usbdev/power/control ]; then
                    if [ "$(cat $usbdev/power/control 2> /dev/null)" != "$control" ]; then
                        # Write actual changes only
                        { printf '%s\n' "$control" > $usbdev/power/control; } 2> /dev/null
                        chg=1
                    fi
                else
                    # level is deprecated
                    if [ "$(cat $usbdev/power/level 2> /dev/null)" != "$control" ]; then
                        # Write actual changes only
                        { printf '%s\n' "$control" > $usbdev/power/level; } 2> /dev/null
                        chg=1
                    fi
                    ctrlf="level"
                fi
                if [ "$X_TLP_USB_SET_AUTOSUSPEND_DELAY" = "1" ]; then
                    # set autosuspend_delay
                    if [ -f $usbdev/power/autosuspend_delay_ms ]; then
                        { printf '%s\n' $USB_TIMEOUT_MS > $usbdev/power/autosuspend_delay_ms; } 2> /dev/null
                    else
                        # autosuspend is deprecated
                        { printf '%s\n' $USB_TIMEOUT > $usbdev/power/autosuspend; } 2> /dev/null
                        autof="autosuspend"
                    fi
                    echo_debug "usb" "set_usb_suspend.$control$exc: $busdev ID $usbid $usbdev [$ctrlf $autof] $drvlist"
                elif [ $chg -eq 1 ]; then
                    # default: change control but not autosuspend_delay, i.e. keep kernel default setting
                    echo_debug "usb" "set_usb_suspend.$control$exc: $busdev ID $usbid $usbdev [$ctrlf] $drvlist"
                else
                    # we didn't change anything actually
                    echo_debug "usb" "set_usb_suspend.$control$exc: $busdev ID $usbid $usbdev $drvlist"
                fi
            fi
        done
        [ "$1" = "1" ] && echo "USB autosuspend settings applied."
    else
        [ "$1" = "1" ] && echo "Error: USB autosuspend is disabled. Set USB_AUTOSUSPEND=1 in $DEFAULT_FILE." 1>&2
    fi

    # set "startup completion" flag for tlp-usb-udev
    set_run_flag $USB_DONE

    return 0
}

# --- [ThinkPad] Battery Features

supports_tpsmapi_only () {
    # rc: 0=ThinkPad supports tpsmapi only/1=false
    # prerequisite: check_thinkpad()
    printf '%s' "$_tpmodel" | egrep -q "${RE_TPSMAPI_ONLY}"
}

supports_tpacpi_only () {
    # rc: 0=ThinkPad supports tpacpi-bat only/1=false
    # prerequisite: check_thinkpad()
    printf '%s' "$_tpmodel" | egrep -q "${RE_TPACPI_ONLY}"
}

supports_tpsmapi_and_tpacpi () {
    # rc: 0=ThinkPad supports tpsmapi and tpacpi-bat/1=false
    # prerequisite: check_thinkpad()
    printf '%s' "$_tpmodel" | egrep -q "${RE_TPSMAPI_AND_TPACPI}"
}

supports_no_tp_bat_funcs () {
    # rc: 0=ThinkPad doesn't support battery features/1=false
    # prerequisite: check_thinkpad()
    printf '%s' "$_tpmodel" | egrep -q "${RE_TP_NONE}"
}

check_battery_features () { # determine which battery feature APIs/tools are
    # supported by hardware and running kernel.
    #
    # 1. check for native kernel acpi (Linux 4.17 or higher required)
    #    --> retval $_natacpi:
    #       0=thresholds and discharge/
    #       1=thresholds only/
    #       32=disabled/
    #       128=no kernel support/
    #       254=laptop not supported
    #
    # 2. check for acpi-call external kernel module and test with integrated
    #    tpacpi-bat [ThinkPads only]
    #    --> retval $_tpacpi:
    #       0=supported/
    #       32=disabled/
    #       64=acpi_call module not loaded/
    #       128=acpi_call module not installed/
    #       254=ThinkPad not supported/
    #       255=superseded by natacpi
    #
    # 3. check for tp-smapi external kernel module [ThinkPads only]
    #    --> retval $_tpsmapi:
    #       0=supported/
    #       32=disabled/
    #       64=tp_smapi module not loaded/
    #       128=tp_smapi module not installed/
    #       254=ThinkPad not supported/
    #       255=superseded by natacpi
    #
    # 4. determine best method for
    #    reading battery data                   --> retval $_bm_read,
    #    reading/writing charging thresholds    --> retval $_bm_thresh,
    #    reading/writing force discharge        --> retval $_bm_dischg:
    #       none/natacpi/tpacpi/tpsmapi
    #
    # prerequisite: check_thinkpad()
    # replaces: check_tpsmapi, check_tpacpi

    # preset: natacpi takes it all
    _natacpi=128
    _tpacpi=255
    _tpsmapi=255
    _bm_read="natacpi"
    _bm_thresh="none"
    _bm_dischg="none"

    # --- 1. check for native kernel ACPI (Linux 4.17 or higher required)
    local ps
    for ps in $ACPIBATDIR/*; do
        if [ "$(cat $ps/present 2> /dev/null)" = "1" ]; then
            # battery detected
            if [ -f $ps/charge_start_threshold ]; then
                # kernel with native acpi support detected
                _natacpi=254

                if [ -n "$(cat $ps/charge_start_threshold 2> /dev/null)" ]; then
                    # charge_start_threshold exists and is actually readable
                    if [ "${NATACPI_ENABLE:-0}" = "1" ]; then
                        _natacpi=1
                        _bm_thresh="natacpi"
                    else
                        _natacpi=32
                    fi
                fi
                if [ $_natacpi != 32 ] && [ -n "$(cat $ps/force_discharge 2> /dev/null)" ]; then
                    # force_discharge exists and is actually readable
                    _natacpi=0
                    _bm_dischg="natacpi"
                fi
            fi
            break # exit loop on first battery detected
        fi
    done
    echo_debug "bat" "check_battery_features.natacpi: $_natacpi (read=$_bm_read; thresh=$_bm_thresh; dischg=$_bm_dischg)"

    # when not a Thinkpad --> we're done
    is_thinkpad || return 0

    # --- 2. check for acpi-call external kernel module and test with integrated tpacpi-bat [ThinkPads only]
    if supports_tpsmapi_only || supports_no_tp_bat_funcs; then
        # not tpacpi-bat capable models
        _tpacpi=254
    elif [ ! -e /proc/acpi/call ]; then
        if [ -z "$(modinfo acpi_call 2> /dev/null)" ]; then
            # module neither installed nor builtin
            _tpacpi=128
        else
            # module not loaded
            _tpacpi=64
        fi
    else
        # module present --> try tpacpi-bat
        $TPACPIBAT -g FD 1 > /dev/null 2>&1
        _tpacpi=$?
        # TODO: handle tpacpi-bat errors (rc=127 when $TPACPIBAT non-existent)

        if [ $_tpacpi -eq 0 ] && [ "${TPACPI_ENABLE:-1}" = "0" ]; then
            # tpacpi disabled by configuration
            _tpacpi=32
        fi

        if [ $_tpacpi -eq 0 ]; then
            # tpacpi available --> fill in methods depending on natacpi results
            case $_natacpi in
                0) ;; # natacpi covers it all

                1) # discharge needed
                    _bm_dischg="tpacpi"
                    ;;

                *) # thresholds and discharge needed
                    _bm_thresh="tpacpi"
                    _bm_dischg="tpacpi"
                    ;;
            esac
        fi
    fi
    echo_debug "bat" "check_battery_features.tpacpi: $_tpacpi (read=$_bm_read; thresh=$_bm_thresh; dischg=$_bm_dischg)"

    # --- 3. check for tp-smapi external kernel module [ThinkPads only]
    if [ -d $SMAPIBATDIR ]; then
        # module loaded --> TPS-MAPI AVAILABLE
        if [ "${TPSMAPI_ENABLE:-1}" = "0" ]; then
            # tpsmapi disabled by configuration
            _tpsmapi=32
        else
            # enabled (default)
            _tpsmapi=0

            # reading battery data via tpsmapi is preferred over natacpi
            # because it provides cycle count and more
            _bm_read="tpsmapi"

            # fill in missing methods
            [ "$_bm_thresh" = "none" ] && _bm_thresh="tpsmapi"
            [ "$_bm_dischg" = "none" ] && _bm_dischg="tpsmapi"
        fi
    elif supports_tpacpi_only || supports_no_tp_bat_funcs; then
        # not tp-smapi capable models
        _tpsmapi=254
    elif [ -n "$(modinfo tp_smapi 2> /dev/null)" ]; then
        # module installed but not loaded
        _tpsmapi=64
    else
        # module not installed
        _tpsmapi=128
    fi
    echo_debug "bat" "check_battery_features.tpsmapi: $_tpsmapi (read=$_bm_read; thresh=$_bm_thresh; dischg=$_bm_dischg)"

    return 0
}

battery_present () { # check battery presence and return tpacpi-bat index
    # $1: BAT0/BAT1/DEF
    # global param: $_bm_read
    # rc: 0=bat exists/1=bat nonexistent/255=no method available
    # retval: $_bat_str:   BAT0/BAT1;
    #         $_bat_idx:   1/2;
    #         $_bd_read:   directory with battery data sysfiles;
    #         $_bf_start:  sysfile for start threshold;
    #         $_bf_stop:   sysfile for stop threshold;
    #         $_bf_dischg: sysfile for force discharge

    # defaults
    local rc=255 # no threshold API available
    _bat_idx=0    # no index
    _bat_str=""   # no bat
    _bd_read=""   # no directories
    _bf_start=""
    _bf_stop=""
    _bf_dischg=""
    local blist bs bsd

    # load modules and check prerequisites
    check_thinkpad
    check_battery_features

    # validate param
    case $1 in
        BAT0|BAT1) blist="$1" ;;
        DEF)       blist="BAT0 BAT1" ;;
        *)         return 1 ;;
    esac

    case $_bm_read in
        natacpi) # note: includes tpacpi
            rc=1
            for bs in $blist; do
                bsd="$ACPIBATDIR/$bs"

                # check acpi name space
                if [ "$(cat $bsd/present 2> /dev/null)" = "1" ] \
                   && [ "$(cat $bsd/type 2> /dev/null)" = "Battery" ]; then
                    rc=0 # battery detected
                    # determine tpacpi-bat index
                    case $bs in
                        BAT0)
                            _bat_str="$bs"
                            _bd_read="$bsd"
                            _bat_idx=1 # BAT0 is always assumed main battery
                            ;;

                        BAT1)
                            _bat_str="$bs"
                            _bd_read="$bsd"
                            if [ -d $ACPIBATDIR/BAT0 ]; then
                                _bat_idx=2 # BAT0 exists --> BAT1 is aux
                            else
                                _bat_idx=1 # BAT0 nonexistent --> BAT1 is main
                            fi
                            ;;
                    esac
                    break # exit loop on first battery detected
                fi
            done
            ;; # natacpi

        tpsmapi)
            rc=1
            for bs in $blist; do
                bsd="$SMAPIBATDIR/$bs"

                # check tp-smapi name space
                if [ "$(cat $bsd/installed 2> /dev/null)" = "1" ]; then
                    rc=0 # battery detected
                    case $bs in
                        BAT0) _bat_str="$bs"; _bd_read="$bsd" ; _bat_idx=1 ;;
                        BAT1) _bat_str="$bs"; _bd_read="$bsd" ; _bat_idx=2 ;;
                    esac
                    break # exit loop on first battery detected
                fi
            done
            ;; # tpsmapi
    esac

    if [ $_bat_idx -ne 0 ]; then
        case $_bm_thresh in
            natacpi)
                _bf_start="$ACPIBATDIR/$_bat_str/charge_start_threshold"
                _bf_stop="$ACPIBATDIR/$_bat_str/charge_stop_threshold"
                ;;

            tpsmapi)
                _bf_start="$SMAPIBATDIR/$_bat_str/start_charge_thresh"
                _bf_stop="$SMAPIBATDIR/$_bat_str/stop_charge_thresh"
                ;;
        esac
        case $_bm_dischg in
            natacpi) _bf_dischg="$ACPIBATDIR/$_bat_str/force_discharge" ;;
            tpsmapi) _bf_dischg="$SMAPIBATDIR/$_bat_str/force_discharge" ;;
        esac
    fi

    echo_debug "bat" "battery_present($1): bm_read=$_bm_read; bat_str=$_bat_str; bat_idx=$_bat_idx; bd_read=$_bd_read; bf_start=$_bf_start; bf_stop=$_bf_stop; bf_dischg=$_bf_dischg; rc=$rc"
    return $rc
}

get_tpacpi_threshold () { # $1: ST/SP (start/stop); $2: 1/2 (battery)
                          # rc: threshold (1..99, 0=default, 255=error)
    local thresh rc

    thresh=$($TPACPIBAT -g $1 $2 2> /dev/null | cut -f1 -d' ')
    rc=$?

    if [ $rc -eq 0 ] && [ -n "$thresh" ]; then
        [ $thresh -ge 128 ] && thresh=$(($thresh - 128)) # Remove offset of 128 for Edge S430
        return $thresh
    else
        return 255
    fi
}

do_threshold () { # $1: start/stop, $2: BAT0/BAT1, $3: new value
    # global param: $_bm_thresh, $_bat_idx, $_bf_start, $_bf_stop
    # rc: 0=ok/1=read error/2=thresh not present/255=no thresh api

    local bsys ts
    local old_thresh=-1
    local new_thresh=$3
    local rc=0

    [ $3 -eq -1 ] && return 0 # -1 = do not set threshold

    case $_bm_thresh in
        natacpi|tpsmapi)
            case $1 in
                start) bsys=$_bf_start ;;
                stop)  bsys=$_bf_stop ;;
            esac
            if [ -f "$bsys" ]; then
                # get effective threshold
                old_thresh=$(cat $bsys 2> /dev/null)
                if [ -z "$old_thresh" ]; then
                    # can't determine effective threshold --> don't write new
                    rc=1
                elif [ "$old_thresh" -ne "$new_thresh" ]; then
                    # when new threshold differs --> write new
                    { printf '%s\n' $new_thresh > $bsys; } 2> /dev/null
                    rc=$?
                fi
            else
                # sysfile non-existent, probably invalid bat argument
                rc=2
            fi
            ;; # natacpi, tpsmapi

        tpacpi) # use tpacpi-bat
            if [ $_bat_idx -ne 0 ]; then
                # bat index is valid

                # replace factory default values with 0 for tpacpi
                case $1 in
                    start)
                        [ $new_thresh -eq  96 ] && new_thresh=0
                        ts="ST"
                        ;;
                    stop)
                        [ $new_thresh -eq 100 ] && new_thresh=0
                        ts="SP"
                        ;;
                esac

                # get effective threshold
                get_tpacpi_threshold $ts $_bat_idx
                old_thresh=$?

                # when new threshold differs --> write new
                if [ $new_thresh -ne $old_thresh ]; then
                    $TPACPIBAT -s $ts $_bat_idx $new_thresh > /dev/null 2>&1
                    rc=$?
                fi
            fi
            ;; # tpacpi

        *) # invalid threshold method
            rc=255
            ;;
    esac

    echo_debug "bat" "do_threshold($1, $2): bm_thresh=$_bm_thresh; bat_idx=$_bat_idx; old=$old_thresh; new=$new_thresh; rc=$rc"
    return $rc
}

normalize_thresholds () { # check values and enforce start < stop - 3
    # $1: start threshold; $2: stop_threshold
    # rc: 0
    # retval: $start_thresh, $stop_thresh

    local type thresh

    for type in start stop; do
        case $type in
            start) thresh=$1 ;;
            stop)  thresh=$2 ;;
        esac

        # check for 1..3 digits, replace with empty string if non-numeric chars are contained
        thresh=$(echo "$thresh" | egrep '^[0-9]{1,3}$')
        # replace empty string with -1
        [ -z "$thresh" ] && thresh=-1

        # ensure min/max values; replace 0 with defaults 96/100
        case $type in
            start)
                [ $thresh -eq 0 ] || [ $thresh -gt 96 ] && thresh=96
                start_thresh=$thresh
                ;;

            stop)
                [ $thresh -eq 0 ] || [ $thresh -gt 100 ] && thresh=100
                [ $thresh -ne -1 ] && [ $thresh -lt 5 ] && thresh=5
                stop_thresh=$thresh
                ;;
        esac
    done

    # enforce start < stop - 3
    if [ $start_thresh -ne -1 ] && [ $stop_thresh -ne -1 ]; then
        [ $start_thresh -ge $(($stop_thresh - 3)) ] && start_thresh=$(($stop_thresh - 4))
    fi

    echo_debug "bat" "normalize_thresholds($1, $2): start=$start_thresh; stop=$stop_thresh"

    return 0
}

set_charge_thresholds () { # write all charge thresholds from configuration
    # rc: 0

    local rc

    if battery_present BAT0; then
        normalize_thresholds "$START_CHARGE_THRESH_BAT0" "$STOP_CHARGE_THRESH_BAT0"

        if [ $stop_thresh -ne -1 ]; then
            do_threshold stop BAT0 $stop_thresh; rc=$?
            echo_debug "bat" "set_charge_thresholds.stop(BAT0): $stop_thresh; rc=$rc"
        else
            echo_debug "bat" "set_charge_thresholds.stop(BAT0).not_set"
        fi

        if [ $start_thresh -ne -1 ]; then
            do_threshold start BAT0 $start_thresh; rc=$?
            echo_debug "bat" "set_charge_thresholds.start(BAT0): $start_thresh; rc=$rc"
        else
            echo_debug "bat" "set_charge_thresholds.start(BAT0).not_set"
        fi
    fi

    if battery_present BAT1; then
        normalize_thresholds "$START_CHARGE_THRESH_BAT1" "$STOP_CHARGE_THRESH_BAT1"

        if [ $stop_thresh -ne -1 ]; then
            do_threshold stop BAT1 $stop_thresh; rc=$?
            echo_debug "bat" "set_charge_thresholds.stop(BAT1): $stop_thresh; rc=$rc"
        else
            echo_debug "bat" "set_charge_thresholds.stop(BAT1).not_set"
        fi

        if [ $start_thresh -ne -1 ]; then
            do_threshold start BAT1 $start_thresh; rc=$?
            echo_debug "bat" "set_charge_thresholds.start(BAT1): $start_thresh; rc=$rc"
        else
            echo_debug "bat" "set_charge_thresholds.start(BAT1).not_set"
        fi
    fi

    return 0
}

do_force_discharge () { # write force discharge state
    # $1: BAT0/BAT1, $2: 0=off/1=on
    # global param: $_bm_dischg, $_bat_idx, $_bf_dischg
    # rc: 0=done/1=write error/2=discharge not present/255=no thresh api

    local rc=0

    case $_bm_dischg in
        natacpi|tpsmapi)
            if [ -f "$_bf_dischg" ]; then
                # write force_discharge
                { printf '%s\n' $2 > $_bf_dischg; } 2> /dev/null; rc=$?
            else
                # sysfile non-existent, possibly invalid bat argument
                rc=2
            fi
            ;; # natacpi, tpsmapi

        tpacpi) # use tpacpi-bat
            $TPACPIBAT -s FD $_bat_idx $2 > /dev/null 2>&1; rc=$?
            ;; # tpcpaci

        *) # invalid discharge method
            rc=255
            ;;
    esac

    echo_debug "bat" "do_force_discharge($1, $2): bm_dischg=$_bm_dischg; bat_idx=$_bat_idx; rc=$rc"

    return $rc
}

get_force_discharge () { # $1: BAT0/BAT1,
    # global param: $_bm_dischg, $_bat_idx, $_bf_dischg
    # rc: 0=off/1=on/2=discharge not present/255=no thresh api

    local bsys rc=0

    case $_bm_dischg in
        natacpi|tpsmapi)
            if [ -f "$_bf_dischg" ]; then
                # read sysfile
                rc=$(cat $_bf_dischg 2> /dev/null)
            else
                # sysfile non-existent
                rc=2
            fi
            ;; # natacpi, tpsmapi

        tpacpi) # read via tpacpi-bat
            case $($TPACPIBAT -g FD $_bat_idx 2> /dev/null) in
                yes) rc=1 ;;
                no)  rc=0 ;;
                *)   rc=2 ;;
            esac
            ;; # tpacpi

        *) # invalid discharge method
            rc=255
            ;;
    esac

    echo_debug "bat" "get_force_discharge($1): bm_dischg=$_bm_dischg; bat_idx=$_bat_idx; rc=$rc"
    return $rc
}

cancel_force_discharge () { # called from trap -- global param: $_bat_str
    do_force_discharge $_bat_str 0
    echo_debug "bat" "force_discharge.cancelled($_bat_str)"
    echo " Cancelled."

    exit 0
}

battery_discharging () { # check if battery is discharging -- $1: BAT0/BAT1,
    # global param: $_bm_read, $_bd_read
    # rc: 0=discharging/1=not discharging/255=no battery api

    local bsys rc=255

    # determine status sysfile
    case $_bm_read in
        natacpi|tpacpi)
            bsys=$_bd_read/status # use ACPI sysfile
            ;;

        tpsmapi)
            bsys=$_bd_read/state # use tpsmapi sysfile
            ;;

        *) # invalid read method
            bsys=""
            rc=255
            ;;
    esac

    # get battery state
    if [ -f "$bsys" ]; then
        case "$(cat $bsys 2> /dev/null)" in
            [Dd]ischarging) rc=0 ;;
            *) rc=1 ;;
        esac
    fi

    echo_debug "bat" "battery_discharging($1): bm_read=$_bm_read; rc=$rc"
    return $rc
}

check_ac_power () { # check if ac power connected -- $1: function

    if ! get_sys_power_supply ; then
        echo_debug "bat" "check_ac_power($1).no_ac_power"
        echo "Error: $1 is possible on AC power only." 1>&2
        return 1
    fi

    return 0
}

setcharge_battery () { # write charge thresholds (called from cmd line)
    # $1: start charge threshold, $2: stop charge threshold, $3: battery
    # rc: 0=ok/1=error

    local bat rc st sp
    local use_cfg=0
    # $_bat_str is global for cancel_force_discharge() trap

    # check params
    case $# in
        0) # no args
            bat=DEF   # use default(1st) battery
            use_cfg=1 # use configured values
            ;;

        1) # assume $1 is battery
            bat=$1
            use_cfg=1 # use configured values
            ;;

        2) # assume $1,$2 are thresholds
            st=$1
            sp=$2
            bat=DEF # use default(1st) battery
            ;;

        3) # assume $1,$2 are thresholds, $3 is battery
            st=$1
            sp=$2
            bat=$3
            ;;
    esac

    # convert bat to uppercase
    bat=$(printf '%s' "$bat" | tr "[:lower:]" "[:upper:]")

    # check bat presence and/or get default(1st) battery
    battery_present $bat
    case $? in
        0) # battery present
            # get configured values if requested
            if [ $use_cfg -eq 1 ]; then
                eval st="\$START_CHARGE_THRESH_${_bat_str}"
                eval sp="\$STOP_CHARGE_THRESH_${_bat_str}"
            fi
            ;;

        255) # no method
            echo "Error: battery feature not available." 1>&2
            echo_debug "bat" "setcharge_battery.no_method"
            return 1
            ;;

        *) # not present
            echo "Error: battery $bat not present." 1>&2
            echo_debug "bat" "setcharge_battery.not_present($bat)"
            return 1
            ;;
    esac

    # validate thresholds
    normalize_thresholds $st $sp

    # write threshold values
    echo "Setting temporary charge thresholds for $_bat_str:"

    if [ $stop_thresh -ne -1 ]; then
        do_threshold stop $_bat_str $stop_thresh; rc=$?

        echo_debug "bat" "setcharge_battery.stop($_bat_str): $stop_thresh; rc=$rc"
        if [ $rc -eq 0 ]; then
            echo "  stop  = $stop_thresh"
        else
            echo "  stop  => Error: cannot set threshold. Aborting." 1>&2
            return 1
        fi
    else
        echo_debug "bat" "setcharge_battery.stop($_bat_str).not_configured"
        echo "  stop = not configured"
    fi

    if [ $start_thresh -ne -1 ]; then
        do_threshold start $_bat_str $start_thresh; rc=$?

        echo_debug "bat" "setcharge_battery.start($_bat_str): $start_thresh; rc=$rc"
        if [ $rc -eq 0 ]; then
            echo "  start = $start_thresh"
        else
            echo "  start => Warning: cannot set threshold." 1>&2
            return 1
        fi
    else
        echo_debug "bat" "setcharge_battery.start($_bat_str).not_configured"
        echo "  start = not configured"
    fi

    return 0
}

get_sysval () { # $1: file; rc: sysfile value
    local sysf="$1"
    local val=""

    # read sysval when it exists
    [ -f $sysf ] && val=$(cat $sysf 2> /dev/null)

    # replace with 0 if empty string or non-numeric chars are contained
    [ -z "$(printf '%s' "$val" | egrep '^[0-9]+$')" ] && val=0

    return $val
}

chargeonce_battery () { # charge battery to upper threshold once
    # $1: battery
    # rc: 0=ok/1=error

    local bat temp_start_thresh
    local start_thresh=""
    local stop_thresh=""
    local efull=0
    local enow=0
    local ccharge=0

    # check params
    if [ $# -gt 0 ]; then
        # some parameters given, check them

        # get battery arg
        bat=${1:-DEF}
        bat=$(printf '%s' "$bat" | tr "[:lower:]" "[:upper:]")
    else
        # no parameters given, use default(1st) battery
        bat=DEF
    fi

    # check if selected battery is present
    battery_present $bat
    case $? in
        0) ;; # battery present

        255) # no method
            echo "Error: battery feature not available." 1>&2
            echo_debug "bat" "chargeonce_battery.no_method"
            return 1
            ;;

        *) # not present
            echo "Error: battery $_bat_str not present." 1>&2
            echo_debug "bat" "chargeonce_battery.not_present($_bat_str)"
            return 1
            ;;
    esac

    # get and check thresholds from configuration)
    eval stop_thresh="\$START_CHARGE_THRESH_${_bat_str}"
    eval start_thresh="\$STOP_CHARGE_THRESH_${_bat_str}"

    [ -z "$stop_thresh" ] && stop_thresh=100
    if [ -z "$start_thresh" ] ; then
        echo_debug "bat" "chargeonce_battery($_bat_str).start_threshold_not_configured"
        echo "Error: no start charge threshold configured for $_bat_str." 1>&2
        return 1
    fi

    # get current charge level (in %)
    case $_bm_read in
        natacpi|tpacpi) # use ACPI sysfiles
            if [ -f $_bd_read/energy_full ]; then
                get_sysval $_bd_read/energy_full; efull=$?
                get_sysval $_bd_read/energy_now; enow=$?
            fi

            if [ $efull -ne 0 ]; then
                ccharge=$(( 100 * $enow / $efull ))
            else
                ccharge=-1
            fi
            ;; # natacpi, tpacpi

        tpsmapi) # use tp-smapi sysfiles
            get_sysval $_bd_read/remaining_percent; ccharge=$?
            ;; # tpsmapi

        *) # invalid read method
            bsys=""
            rc=255
            ;;
    esac

    if [ $ccharge -eq -1 ] ; then
        echo_debug "bat" "chargeonce_battery($_bat_str).charge_level_unknown: enow=$enow; efull=$efull; ccharge=$ccharge"
        echo "Error: cannot determine charge level for $_bat_str." 1>&2
        return 1
    else
        echo_debug "bat" "chargeonce_battery($_bat_str).charge_level: enow=$enow; efull=$efull; ccharge=$ccharge"
    fi

    temp_start_thresh=$(( $stop_thresh - 4 ))
    if [ $temp_start_thresh -le $ccharge ] ; then
        echo_debug "bat" "chargeonce_battery($_bat_str).charge_level_too_high: $temp_start_thresh $stop_thresh"
        echo "Error: current charge level ($ccharge) of $_bat_str is higher than stop charge threshold - 4 ($temp_start_thresh)." 1>&2
        return 1
    else
        echo_debug "bat" "chargeonce_battery($_bat_str).setcharge: $temp_start_thresh $stop_thresh"
    fi

    setcharge_battery $temp_start_thresh $stop_thresh $_bat_str
    return $?
}

discharge_battery () { # discharge battery
    # $1: battery
    # global param: $_tpacpi, $_tpsmapi
    # rc: 0=ok/1=error

    local bat en ef pn rc wt
    # $_bat_str is global for cancel_force_discharge() trap

    # check params
    bat=$1
    bat=${bat:=DEF}
    bat=$(printf '%s' "$bat" | tr "[:lower:]" "[:upper:]")

    # check if selected battery is present
    battery_present $bat
    case $? in
        0) ;; # battery present

        255) # no method
            echo "Error: battery feature not available." 1>&2
            echo_debug "bat" "discharge_battery.no_method"
            return 1
            ;;

        *) # not present
            echo "Error: battery $bat not present." 1>&2
            echo_debug "bat" "discharge_battery.not_present($bat)"
            return 1
            ;;
    esac

    # start discharge
    do_force_discharge $_bat_str 1; rc=$?
    if [ $rc -ne 0 ]; then
        echo_debug "bat" "discharge_battery.force_discharge_not_available($_bat_str)"
        echo "Error: discharge function not available for this laptop." 1>&2
        return 1
    fi

    trap cancel_force_discharge INT # enable ^C hook

    # wait for start == while status not "discharging" -- 5.0 sec timeout
    wt=10
    while ! battery_discharging $_bat_str && [ $wt -gt 0 ] ; do sleep 0.5; wt=$((wt - 1)); done

    if battery_discharging $_bat_str; then
        # discharge initiated sucessfully --> wait for completion == while status "discharging"
        echo_debug "bat" "discharge_battery.running($_bat_str)"

        while battery_discharging $_bat_str; do
            clear
            echo "Currently discharging battery $_bat_str:"

            # show current battery state
            case $_bm_read in
                natacpi|tpacpi) # use ACPI sysfiles
                    perl -e 'printf ("voltage            = %6d [mV]\n", '$(catsysfd $_bd_read/voltage_now 0 2> /dev/null)' / 1000.0);'

                    en=$(catsysfd $_bd_read/energy_now 0 2> /dev/null)
                    perl -e 'printf ("remaining capacity = %6d [mWh]\n", '$en' / 1000.0);'

                    ef=$(catsysfd $_bd_read/energy_full 0 2> /dev/null)
                    if [ "$ef" != "0" ]; then
                        perl -e 'printf ("remaining percent  = %6d [%%]\n", 100.0 * '$en' / '$ef' );'
                    else
                        printf "remaining percent  = not available [%]\n"
                    fi

                    pn=$(catsysfd $_bd_read/power_now 0 2> /dev/null)
                    if [ "$pn" != "0" ]; then
                        perl -e 'printf ("remaining time     = %6d [min]\n", 60.0 * '$en' / '$pn');'
                        perl -e 'printf ("power              = %6d [mW]\n", '$pn' / 1000.0);'
                    else
                        printf "remaining time     = not discharging [min]\n"
                    fi
                    printf "state              = %s\n"  "$(cat $_bd_read/status 2> /dev/null)"
                    ;; # natacpi, tpsmapi

                tpsmapi) # use tp-smapi sysfiles
                    printf "voltage            = %6s [mV]\n"  "$(cat $_bd_read/voltage 2> /dev/null)"
                    printf "remaining capacity = %6s [mWh]\n" "$(cat $_bd_read/remaining_capacity 2> /dev/null)"
                    printf "remaining percent  = %6s [%%]\n"  "$(cat $_bd_read/remaining_percent 2> /dev/null)"
                    printf "remaining time     = %6s [min]\n" "$(cat $_bd_read/remaining_running_time_now 2> /dev/null)"
                    printf "power              = %6s [mW]\n"  "$(cat $_bd_read/power_avg 2> /dev/null)"
                    printf "state              = %s\n"  "$(cat $_bd_read/state 2> /dev/null)"
                    ;; # tpsmapi

            esac
            get_force_discharge $_bat_str; printf "force discharge    = %s\n"  "$?"

            echo "Press Ctrl+C to cancel."
            sleep 5
        done
    else
        # discharge malfunction --> cancel discharge and abort
        do_force_discharge $_bat_str 0;
        echo_debug "bat" "discharge_battery.malfunction($_bat_str)"
        echo "Error: discharge $_bat_str malfunction." 1>&2
        trap - INT # remove ^C hook
        return 1
    fi

    trap - INT # remove ^C hook

    # ThinkPad E-series firmware may keep force_discharge active --> cancel it
    ! get_force_discharge $_bat_str && do_force_discharge $_bat_str 0

    echo
    echo "Done: battery $_bat_str was completely discharged."
    echo_debug "bat" "discharge_battery.complete($_bat_str)"
    return 0
}

# --- Drive Bay

get_drivebay_device () { # Find generic dock interface for drive bay
                         # rc: 0; retval: $dock
    dock=$(grep -l ata_bay $DOCKGLOB/type 2> /dev/null)
    dock=${dock%%/type}
    if [ ! -d "$dock" ]; then
        dock=""
    fi

    return 0
}

check_is_docked() { # check if $dock is docked;
                    # rc: 0 if docked, else 1

   local dock_status dock_info_file

   # return 0 if any sysfs file indicates "docked"
   for dock_info_file in docked firmware_node/status; do
        if [ -f $dock/$dock_info_file ] && \
            read -r dock_status < $dock/$dock_info_file 2>/dev/null; then
            # catch empty $dock_status (safety check, unlikely case)
            [ "${dock_status:-0}" != "0" ] && return 0
        fi
   done

   # otherwise assume "not docked"
   return 1
}

poweroff_drivebay () { # power off optical drive in drive bay
    # $1: 0=ac mode, 1=battery mode
    # $2: 0=conditional+quiet mode, 1=force+verbose mode
    # Some code adapted from http://www.thinkwiki.org/wiki/How_to_hotswap_UltraBay_devices

    local pwr optdrv syspath

    if [ "$1" = "1" ]; then
        pwr=${BAY_POWEROFF_ON_BAT:-0}
    else
        pwr=${BAY_POWEROFF_ON_AC:-0}
    fi

    # Run only if either explicitly enabled or forced
    [ "$pwr" = "1" ] || [ "$2" = "1" ] || return 0

    get_drivebay_device
    if [ -z "$dock" ] || [ ! -d "$dock" ]; then
        echo_debug "pm" "poweroff_drivebay($1).no_bay_device"
        [ "$2" = "1" ] && echo "Error: cannot locate bay device." 1>&2
        return 1
    fi
    echo_debug "pm" "poweroff_drivebay($1): dock=$dock"

    # Check if bay is occupied
    if ! check_is_docked; then
        echo_debug "pm" "poweroff_drivebay($1).drive_already_off"
        [ "$2" = "1" ] && echo "No drive in bay (or power already off)."
    else
        # Check for optical drive
        optdrv=/dev/${BAY_DEVICE:=sr0}
        if [ ! -b "$optdrv" ]; then
            echo_debug "pm" "poweroff_drivebay($1).no_opt_drive: $optdrv"
            [ "$2" = "1" ] && echo "No optical drive in bay ($optdrv)."
            return 0
        else
            echo_debug "pm" "poweroff_drivebay($1): optdrv=$optdrv"

            echo -n "Powering off drive bay..."

            # Unmount media
            umount -l $optdrv > /dev/null 2>&1

            # Sync drive
            sync
            sleep 1

            # Power off drive
            $HDPARM -Y $optdrv > /dev/null 2>&1
            sleep 5

            # Unregister scsi device
            if syspath="$($UDEVADM info --query=path --name=$optdrv)"; then
                syspath="/sys${syspath%/block/*}"

                if [ "$syspath" != "/sys" ]; then
                    echo_debug "pm" "poweroff_drivebay($1): syspath=$syspath"
                    { printf '%s\n' "1" > $syspath/delete; } 2> /dev/null
                else
                    echo_debug "pm" "poweroff_drivebay($1): got empty/invalid syspath for $optdrv"
                fi
            else
                echo_debug "pm" "poweroff_drivebay($1): failed to get syspath (udevadm returned $?)"
            fi

            # Turn power off
            { printf '%s\n' "1" > $dock/undock; } 2> /dev/null
            [ "$2" = "1" ] && echo "done."
            echo_debug "pm" "poweroff_drivebay($1).bay_powered_off"
        fi
    fi

    return 0
}

suspend_drivebay () { # Save power state of drive bay before suspend
                      # $1: 0=ac mode, 1=battery mode

    if [ "$1" = "1" ] && [ "$BAY_POWEROFF_ON_BAT" = "1" ] || \
       [ "$1" = "0" ] && [ "$BAY_POWEROFF_ON_AC"  = "1" ]; then
        # setting corresponding to mode is active -> save state
        get_drivebay_device

        if [ -n "$dock" ]; then
            create_rundir

            if ! check_is_docked; then
                { printf '%s\n' "off" > $BAYSTATEFILE; } 2> /dev/null
                echo_debug "pm" "suspend_drivebay($1): bay=off"
            else
                { printf '%s\n' "on" > $BAYSTATEFILE; } 2> /dev/null
                echo_debug "pm" "suspend_drivebay($1): bay=on"
            fi
        fi
    else
        # setting not active -> remove state file
        rm -f $BAYSTATEFILE 2> /dev/null
    fi

    return 0
}

resume_drivebay () { #
    # $1: 0=ac mode, 1=battery mode

    local cnt rc

    if [ "$(cat $BAYSTATEFILE 2> /dev/null)" = "off" ]; then
        # saved state = off
        get_drivebay_device

        if [ -n "$dock" ]; then
            if check_is_docked; then
                # device active -> deactivate
                if [ -e $dock/undock ]; then
                    cnt=5
                    rc=1
                    until [ $rc = 0 -o $cnt = 0 ]; do
                        cnt=$((cnt - 1))
                        { printf '%s\n' "1" > $dock/undock; } 2> /dev/null
                        rc=$?
                        [ $rc = 0 ] || sleep 0.5
                    done
                    echo_debug "pm" "resume_drivebay.bay_off: rc=$rc"
                fi
            else
                echo_debug "pm" "resume_drivebay.already_off"
            fi
        fi
    else
        # No saved state or state != off --> apply settings
        poweroff_drivebay $1 0
    fi

    rm -f $BAYSTATEFILE 2> /dev/null

    return 0
}
